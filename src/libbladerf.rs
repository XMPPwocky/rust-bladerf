/* automatically generated by rust-bindgen */

pub enum bladerf_stream { }

pub type __darwin_size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf([u8; 0]);
pub const BLADERF_BACKEND_ANY: _bindgen_ty_6 =
    _bindgen_ty_6::BLADERF_BACKEND_ANY;
pub const BLADERF_BACKEND_LINUX: _bindgen_ty_6 =
    _bindgen_ty_6::BLADERF_BACKEND_LINUX;
pub const BLADERF_BACKEND_LIBUSB: _bindgen_ty_6 =
    _bindgen_ty_6::BLADERF_BACKEND_LIBUSB;
pub const BLADERF_BACKEND_CYPRESS: _bindgen_ty_6 =
    _bindgen_ty_6::BLADERF_BACKEND_CYPRESS;
pub const BLADERF_BACKEND_DUMMY: _bindgen_ty_6 =
    _bindgen_ty_6::BLADERF_BACKEND_DUMMY;
#[repr(u32)]
/**
 * Backend by which the host communicates with the device
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    BLADERF_BACKEND_ANY = 0,
    BLADERF_BACKEND_LINUX = 1,
    BLADERF_BACKEND_LIBUSB = 2,
    BLADERF_BACKEND_CYPRESS = 3,
    BLADERF_BACKEND_DUMMY = 100,
}
pub use self::_bindgen_ty_6 as bladerf_backend;
/**
 * Information about a bladeRF attached to the system
 */
#[repr(C)]
pub struct bladerf_devinfo {
    /**< Backend to use when connecting to device */
    pub backend: bladerf_backend,
    /**< Device serial number string */
    pub serial: [::std::os::raw::c_char; 33usize],
    /**< Bus # device is attached to */
    pub usb_bus: u8,
    /**< Device address on bus */
    pub usb_addr: u8,
    /**< Device instance or ID */
    pub instance: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_bladerf_devinfo() {
    assert_eq!(::std::mem::size_of::<bladerf_devinfo>() , 44usize);
    assert_eq!(::std::mem::align_of::<bladerf_devinfo>() , 4usize);
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Obtain a list of bladeRF devices attached to the system
 *
 * @param[out]  devices
 *
 * @return number of items in returned device list, or value from
 *         \ref RETCODES list on failure
 */
    pub fn bladerf_get_device_list(devices: &*mut bladerf_devinfo)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Free device list returned by bladerf_get_device_list()
 *
 * @param   devices     List of available devices
 */
    pub fn bladerf_free_device_list(devices: *mut bladerf_devinfo);
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Initialize a device identifier information structure to a "wildcard" state.
 * The values in each field will match any value for that field.
 *
 * Passing a bladerf_devinfo initialized with this function to
 * bladerf_open_with_devinfo() will match the first device found.
 */
    pub fn bladerf_init_devinfo(info: *mut bladerf_devinfo);
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Fill out a provided bladerf_devinfo structure, given an open device handle.
 *
 * @pre dev must be a valid device handle.
 *
 * @param[in]    dev     Device handle previously obtained with bladerf_open()
 * @param[out]   info    Device information populated by this function
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_devinfo(dev: *mut bladerf, info: *mut bladerf_devinfo)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Populate a device identifier information structure using the provided
 * device identifier string.
 jjk*
 * @param[in]   devstr  Device identifier string, formated as described
 *                      in the bladerf_open() documentation
 *
 * @param[out]  info    Upon success, this will be filled out according to the
 *                      provided device identifier string, with wildcards for
 *                      any fields that were not provided.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_devinfo_from_str(devstr: *const ::std::os::raw::c_char,
                                        info: *mut bladerf_devinfo)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Test whether two device identifier information structures match, taking
 * wildcard values into account.
 */
    pub fn bladerf_devinfo_matches(a: *const bladerf_devinfo,
                                   b: *const bladerf_devinfo) -> bool;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Test whether a provided device string matches a device described by
 * the provided bladerf_devinfo structure
 *
 * @param[in]   dev_str     Devices string, formated as described in the
 *                          the documentation of bladerf_open
 *
 * @param[in]   info        Device info to compare with
 *
 * @return  true upon a match, false otherwise
 */
    pub fn bladerf_devstr_matches(dev_str: *const ::std::os::raw::c_char,
                                  info: *mut bladerf_devinfo) -> bool;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Opens device specified by provided bladerf_devinfo structure
 *
 * This function is generally preferred over bladerf_open() when a device
 * identifier string is not already provided.
 *
 * The most common uses of this function are to:
 *  - Open a device based upon the results of bladerf_get_device_list()
 *  - Open a specific device based upon its serial number
 *
 * Below is an example of how to use this function to open a device with a
 * specific serial number:
 *
 * @snippet open_via_serial.c example_snippet
 *
 * @param[out]  device      Update with device handle on success
 * @param[in]   devinfo     Device specification. If NULL, any available
 *                          device will be opened.
 *
 * @return 0 on success, or value from \ref RETCODES list on failure
 */
    pub fn bladerf_open_with_devinfo(device: &*mut bladerf,
                                     devinfo: *const bladerf_devinfo)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Open specified device using a device identifier string. See
 * bladerf_open_with_devinfo() if a device identifier string is not readily
 * available.
 *
 * The general form of the device identifier string is;
 * @code{.txt}
 *      <backend>:[device=<bus>:<addr>] [instance=<n>] [serial=<serial>]
 * @endcode
 *
 * An empty ("") or NULL device identifier will result in the first
 * encountered device being opened (using the first discovered backend)
 *
 * The 'backend' describes the mechanism used to communicate with the device,
 * and may be one of the following:
 *   - *:       Any available backend
 *   - libusb:  libusb (See libusb changelog notes for required version, given
 *   your OS and controller)
 *   - cypress: Cypress CyUSB/CyAPI backend (Windows only)
 *
 * If no arguments are provided after the backend, the first encountered
 * device on the specified backend will be opened. Note that a backend is
 * required, if any arguments are to be provided.
 *
 * Next, any provided arguments are provide as used to find the desired device.
 * Be sure not to over constrain the search. Generally, only one of the above
 * is required -- providing all of these may over constrain the search for the
 * desired device (e.g., if a serial number matches, but not on the specified
 * bus and address.)
 *
 *   - device=\<bus\>:\<addr\>
 *      - Specifies USB bus and address. Decimal or hex prefixed by '0x' is
 *        permitted.
 *   - instance=\<n\>
 *      - Nth instance encountered, 0-indexed
 *   - serial=\<serial\>
 *      - Device's serial number.
 *
 * Below is an example of how to open a device with a specific serial
 * number, using any avaiable backend supported by libbladeRF:
 *
 * @code {.c}
 * struct bladerf *dev;
 * int status = bladerf_open(&dev, "*:serial=f12ce1037830a1b27f3ceeba1f521413");
 * if (status != 0) {
 *      fprintf(stderr, "Unable to open device: %s\n",
 *              bladerf_strerror(status));
 *      return status;
 * }
 * @endcode
 *
 * @param[out]  device             Update with device handle on success
 * @param[in]   device_identifier  Device identifier, formatted as described
 *                                 above
 *
 * @return 0 on success, or value from \ref RETCODES list on failure
 */
    pub fn bladerf_open(device: &*mut bladerf,
                        device_identifier: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Close device
 *
 * @note    Failing to close a device will result in memory leaks.
 *
 * @post    device is deallocated and may no longer be used.
 *
 * @param   device  Device handle previously obtained by bladerf_open(). This
 *                  function does nothing if device is NULL.
 */
    pub fn bladerf_close(device: *mut bladerf);
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Enable or disable USB device reset operation upon opening a device for
 * future bladerf_open() and bladerf_open_with_devinfo() calls.
 *
 * This operation has been found to be necessary on Linux-based systems for
 * some USB 3.0 controllers on Linux.
 *
 * This <b>does not</b> reset the state of the device in terms of its frequency,
 * gain, samplerate, etc. settings.
 *
 * @param   enabled     Set true to enable the use of the USB device reset,
 *                      and false otherwise.
 */
    pub fn bladerf_set_usb_reset_on_open(enabled: bool);
}
/**
 * Version structure for FPGA, firmware, libbladeRF, and associated utilities
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bladerf_version {
    /**< Major version */
    pub major: u16,
    /**< Minor version */
    pub minor: u16,
    /**< Patch version */
    pub patch: u16,
    /**< Version string with any additional suffix
                                 *   information.
                                 *
                                 *   @warning Do not attempt to modify or
                                 *            free() this string. */
    pub describe: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_bladerf_version() {
    assert_eq!(::std::mem::size_of::<bladerf_version>() , 16usize);
    assert_eq!(::std::mem::align_of::<bladerf_version>() , 8usize);
}
impl Clone for bladerf_version {
    fn clone(&self) -> Self { *self }
}
pub const BLADERF_FPGA_UNKNOWN: _bindgen_ty_7 =
    _bindgen_ty_7::BLADERF_FPGA_UNKNOWN;
pub const BLADERF_FPGA_40KLE: _bindgen_ty_7 =
    _bindgen_ty_7::BLADERF_FPGA_40KLE;
pub const BLADERF_FPGA_115KLE: _bindgen_ty_7 =
    _bindgen_ty_7::BLADERF_FPGA_115KLE;
#[repr(u32)]
/**
 * FPGA device variant (size)
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    BLADERF_FPGA_UNKNOWN = 0,
    BLADERF_FPGA_40KLE = 40,
    BLADERF_FPGA_115KLE = 115,
}
pub use self::_bindgen_ty_7 as bladerf_fpga_size;
pub const BLADERF_DEVICE_SPEED_UNKNOWN: _bindgen_ty_8 =
    _bindgen_ty_8::BLADERF_DEVICE_SPEED_UNKNOWN;
pub const BLADERF_DEVICE_SPEED_HIGH: _bindgen_ty_8 =
    _bindgen_ty_8::BLADERF_DEVICE_SPEED_HIGH;
pub const BLADERF_DEVICE_SPEED_SUPER: _bindgen_ty_8 =
    _bindgen_ty_8::BLADERF_DEVICE_SPEED_SUPER;
#[repr(u32)]
/**
 * This enum describes the USB Speed at which the bladeRF is connected.
 * Speeds not listed here are not supported.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    BLADERF_DEVICE_SPEED_UNKNOWN = 0,
    BLADERF_DEVICE_SPEED_HIGH = 1,
    BLADERF_DEVICE_SPEED_SUPER = 2,
}
pub use self::_bindgen_ty_8 as bladerf_dev_speed;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Query a device's serial number
 *
 * @param[in]   dev     Device handle
 * @param[out]  serial  This user-supplied buffer, which <b>must be at least
 *                      ::BLADERF_SERIAL_LENGTH bytes</b>, will be updated to
 *                      contain a NUL-terminated serial number string. If an
 *                      error occurs (as indicated by a non-zero return value),
 *                      no data will be written to this pointer.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_serial(dev: *mut bladerf,
                              serial: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Query a device's VCTCXO calibration trim
 *
 * @param[in]   dev     Device handle
 * @param[out]  trim    Will be updated with the factory DAC trim value. If an
 *                      error occurs, no data will be written to this pointer.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_vctcxo_trim(dev: *mut bladerf, trim: *mut u16)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Query a device's FPGA size
 *
 * @param[in]   dev     Device handle
 * @param[out]  size    Will be updated with the on-board FPGA's size. If an
 *                      error occurs, no data will be written to this pointer.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_fpga_size(dev: *mut bladerf,
                                 size: *mut bladerf_fpga_size)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Query firmware version
 *
 * @param[in]   dev         Device handle
 * @param[out]  version     Updated to contain firmware version
 *
 * @return 0 on success, value from \ref RETCODES list upon failing to retrieve
 *         this information from the device.
 */
    pub fn bladerf_fw_version(dev: *mut bladerf,
                              version: *mut bladerf_version)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Check FPGA configuration status
 *
 * @param   dev     Device handle
 *
 * @return  1 if FPGA is configured,
 *          0 if it is not,
 *          and value from \ref RETCODES list on failure
 */
    pub fn bladerf_is_fpga_configured(dev: *mut bladerf)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Query FPGA version
 *
 * @param[in]   dev         Device handle
 * @param[out]  version     Updated to contain firmware version
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_fpga_version(dev: *mut bladerf,
                                version: *mut bladerf_version)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Obtain the bus speed at which the device is operating
 *
 * @param       dev     Device handle
 * @return      speed   Device speed
 */
    pub fn bladerf_device_speed(dev: *mut bladerf) -> bladerf_dev_speed;
}
pub const BLADERF_MODULE_INVALID: _bindgen_ty_9 =
    _bindgen_ty_9::BLADERF_MODULE_INVALID;
pub const BLADERF_MODULE_RX: _bindgen_ty_9 = _bindgen_ty_9::BLADERF_MODULE_RX;
pub const BLADERF_MODULE_TX: _bindgen_ty_9 = _bindgen_ty_9::BLADERF_MODULE_TX;
#[repr(i32)]
/**
 * Module selection for those which have both RX and TX constituents
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    BLADERF_MODULE_INVALID = -1,
    BLADERF_MODULE_RX = 0,
    BLADERF_MODULE_TX = 1,
}
pub use self::_bindgen_ty_9 as bladerf_module;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Enable or disable the specified RX/TX module.
 *
 * RX and TX modules must always be enabled prior to streaming samples
 * on the associated interface.
 *
 * When a synchronous stream is associated with the specified module, this
 * will shut down the underlying asynchronous stream when `enable` = false.
 *
 * When transmitting samples, be sure to provide ample time for TX samples reach
 * the RF front-end before calling this function with `enable` = false. (This
 * can be achieved easily when using metadata, as shown on
 * <a class="el" href="sync_tx_meta_bursts.html">this page</a>.)
 *
 * @param       dev     Device handle
 * @param       m       Device module
 * @param       enable  true to enable, false to disable
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_enable_module(dev: *mut bladerf, m: bladerf_module,
                                 enable: bool) -> ::std::os::raw::c_int;
}
pub const BLADERF_LNA_GAIN_UNKNOWN: _bindgen_ty_10 =
    _bindgen_ty_10::BLADERF_LNA_GAIN_UNKNOWN;
pub const BLADERF_LNA_GAIN_BYPASS: _bindgen_ty_10 =
    _bindgen_ty_10::BLADERF_LNA_GAIN_BYPASS;
pub const BLADERF_LNA_GAIN_MID: _bindgen_ty_10 =
    _bindgen_ty_10::BLADERF_LNA_GAIN_MID;
pub const BLADERF_LNA_GAIN_MAX: _bindgen_ty_10 =
    _bindgen_ty_10::BLADERF_LNA_GAIN_MAX;
#[repr(u32)]
/**
 * LNA gain options
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    BLADERF_LNA_GAIN_UNKNOWN = 0,
    BLADERF_LNA_GAIN_BYPASS = 1,
    BLADERF_LNA_GAIN_MID = 2,
    BLADERF_LNA_GAIN_MAX = 3,
}
pub use self::_bindgen_ty_10 as bladerf_lna_gain;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the PA gain in dB
 *
 * Values outside the range of
 * [ \ref BLADERF_TXVGA2_GAIN_MIN, \ref BLADERF_TXVGA2_GAIN_MAX ]
 * will be clamped.
 *
 * @param       dev         Device handle
 * @param       gain        Desired gain
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_txvga2(dev: *mut bladerf, gain: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get the PA gain in dB
 *
 * @param       dev         Device handle
 * @param       gain        Pointer to returned gain
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_txvga2(dev: *mut bladerf,
                              gain: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the post-LPF gain in dB
 *
 * Values outside the range of
 * [ \ref BLADERF_TXVGA1_GAIN_MIN, \ref BLADERF_TXVGA1_GAIN_MAX ]
 * will be clamped.
 *
 * @param       dev         Device handle
 * @param       gain        Desired gain
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_txvga1(dev: *mut bladerf, gain: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get the post-LPF gain in dB
 *
 * @param       dev         Device handle
 * @param       gain        Pointer to returned gain
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_txvga1(dev: *mut bladerf,
                              gain: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the LNA gain
 *
 * @param       dev         Device handle
 * @param       gain        Desired gain level
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_lna_gain(dev: *mut bladerf, gain: bladerf_lna_gain)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get the LNA gain
 *
 * @param       dev         Device handle
 * @param       gain        Pointer to the set gain level
 */
    pub fn bladerf_get_lna_gain(dev: *mut bladerf,
                                gain: *mut bladerf_lna_gain)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the pre-LPF VGA gain
 *
 * Values outside the range of
 * [ \ref BLADERF_RXVGA1_GAIN_MIN, \ref BLADERF_RXVGA1_GAIN_MAX ]
 * will be clamped.
 *
 * @param       dev         Device handle
 * @param       gain        Desired gain
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_rxvga1(dev: *mut bladerf, gain: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get the pre-LPF VGA gain
 *
 * @param       dev         Device handle
 * @param       gain        Pointer to the set gain level
 */
    pub fn bladerf_get_rxvga1(dev: *mut bladerf,
                              gain: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the post-LPF VGA gain
 *
 * Values outside the range of
 * [ \ref BLADERF_RXVGA2_GAIN_MIN, \ref BLADERF_RXVGA2_GAIN_MAX ]
 * will be clamped.
 *
 * @param       dev         Device handle
 * @param       gain        Desired gain
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_rxvga2(dev: *mut bladerf, gain: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get the post-LPF VGA gain
 *
 * @param       dev         Device handle
 * @param       gain        Pointer to the set gain level
 */
    pub fn bladerf_get_rxvga2(dev: *mut bladerf,
                              gain: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set combined gain values
 *
 * This function computes the optimal LNA, RXVGA1, and RVGA2 gains for a
 * requested amount of RX gain, and computes the optimal TXVGA1 and TXVGA2 gains
 * for a requested amount of TX gain.
 *
 * Values outside the valid gain range will be clipped.
 *
 * @param       dev         Device handle
 * @param       mod         Module
 * @param       gain        Desired gain
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_gain(dev: *mut bladerf, mod_: bladerf_module,
                            gain: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub const BLADERF_RX_MUX_INVALID: _bindgen_ty_11 =
    _bindgen_ty_11::BLADERF_RX_MUX_INVALID;
pub const BLADERF_RX_MUX_BASEBAND_LMS: _bindgen_ty_11 =
    _bindgen_ty_11::BLADERF_RX_MUX_BASEBAND_LMS;
pub const BLADERF_RX_MUX_12BIT_COUNTER: _bindgen_ty_11 =
    _bindgen_ty_11::BLADERF_RX_MUX_12BIT_COUNTER;
pub const BLADERF_RX_MUX_32BIT_COUNTER: _bindgen_ty_11 =
    _bindgen_ty_11::BLADERF_RX_MUX_32BIT_COUNTER;
pub const BLADERF_RX_MUX_DIGITAL_LOOPBACK: _bindgen_ty_11 =
    _bindgen_ty_11::BLADERF_RX_MUX_DIGITAL_LOOPBACK;
#[repr(i32)]
/**
 * RX Mux modes
 *
 * These values describe the source of samples to the RX FIFOs in the FPGA.
 * They map directly to rx_mux_mode_t inside the FPGA's source code.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 {
    BLADERF_RX_MUX_INVALID = -1,
    BLADERF_RX_MUX_BASEBAND_LMS = 0,
    BLADERF_RX_MUX_12BIT_COUNTER = 1,
    BLADERF_RX_MUX_32BIT_COUNTER = 2,
    BLADERF_RX_MUX_DIGITAL_LOOPBACK = 4,
}
pub use self::_bindgen_ty_11 as bladerf_rx_mux;
/**
 * Rational sample rate representation
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bladerf_rational_rate {
    /**< Integer portion */
    pub integer: u64,
    /**< Numerator in fractional portion */
    pub num: u64,
    /**< Denominator in fractional portion. This
                                     must be > 0. */
    pub den: u64,
}
#[test]
fn bindgen_test_layout_bladerf_rational_rate() {
    assert_eq!(::std::mem::size_of::<bladerf_rational_rate>() , 24usize);
    assert_eq!(::std::mem::align_of::<bladerf_rational_rate>() , 8usize);
}
impl Clone for bladerf_rational_rate {
    fn clone(&self) -> Self { *self }
}
pub const BLADERF_SAMPLING_UNKNOWN: _bindgen_ty_12 =
    _bindgen_ty_12::BLADERF_SAMPLING_UNKNOWN;
pub const BLADERF_SAMPLING_INTERNAL: _bindgen_ty_12 =
    _bindgen_ty_12::BLADERF_SAMPLING_INTERNAL;
pub const BLADERF_SAMPLING_EXTERNAL: _bindgen_ty_12 =
    _bindgen_ty_12::BLADERF_SAMPLING_EXTERNAL;
#[repr(u32)]
/**
 * Sampling connection
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 {
    BLADERF_SAMPLING_UNKNOWN = 0,
    BLADERF_SAMPLING_INTERNAL = 1,
    BLADERF_SAMPLING_EXTERNAL = 2,
}
pub use self::_bindgen_ty_12 as bladerf_sampling;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Configure the device's sample rate, in Hz.  Note this requires the sample
 * rate is an integer value of Hz.  Use bladerf_set_rational_sample_rate()
 * for more arbitrary values.
 *
 * The sample rate must be greater than or equal to \ref BLADERF_SAMPLERATE_MIN.
 * Values above \ref BLADERF_SAMPLERATE_REC_MAX are allowed, but not
 * recommended. Setting the sample rates higher than recommended max may yield
 * errors and unexpected results.
 *
 * @param[in]   dev         Device handle
 * @param[in]   module      Module to change
 * @param[in]   rate        Sample rate
 * @param[out]  actual      If non-NULL. this is written with the actual
 *                          sample rate achieved.
 *
 * @return 0 on success,
 *         BLADERF_ERR_INVAL for an invalid sample rate,
 *         or a value from \ref RETCODES list on other failures
 */
    pub fn bladerf_set_sample_rate(dev: *mut bladerf, module: bladerf_module,
                                   rate: ::std::os::raw::c_uint,
                                   actual: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Configure the device's sample rate as a rational fraction of Hz.
 * Sample rates are in the form of integer + num/denom.
 *
 * @param[in]   dev         Device handle
 * @param[in]   module      Module to change
 * @param[in]   rate        Rational sample rate
 * @param[out]  actual      If non-NULL, this is written with the actual
 *                          rational sample rate achieved.
 *
 * The sample rate must be greater than or equal to \ref BLADERF_SAMPLERATE_MIN.
 * Values above \ref BLADERF_SAMPLERATE_REC_MAX are allowed, but not
 * recommended. Setting the sample rates higher than recommended max may yield
 * errors and unexpected results.
 *
 * @return 0 on success,
 *         BLADERF_ERR_INVAL for an invalid sample rate,
 *         or a value from \ref RETCODES list on other failures
 */
    pub fn bladerf_set_rational_sample_rate(dev: *mut bladerf,
                                            module: bladerf_module,
                                            rate: *mut bladerf_rational_rate,
                                            actual:
                                                *mut bladerf_rational_rate)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read the device's sample rate in Hz
 *
 * @param[in]   dev         Device handle
 * @param[in]   module      Module to query
 * @param[out]  rate        Pointer to returned sample rate
 *
 * @return 0 on success, value from \ref RETCODES list upon failure
 */
    pub fn bladerf_get_sample_rate(dev: *mut bladerf, module: bladerf_module,
                                   rate: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read the device's sample rate in rational Hz
 *
 * @param[in]   dev         Device handle
 * @param[in]   module      Module to query
 * @param[out]  rate        Pointer to returned rational sample rate
 *
 * @return 0 on success, value from \ref RETCODES list upon failure
 */
    pub fn bladerf_get_rational_sample_rate(dev: *mut bladerf,
                                            module: bladerf_module,
                                            rate: *mut bladerf_rational_rate)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Configure the sampling of the LMS6002D to be either internal or
 * external.  Internal sampling will read from the RXVGA2 driver internal
 * to the chip.  External sampling will connect the ADC inputs to the
 * external inputs for direct sampling.
 *
 * @param[in]   dev         Device handle
 * @param[in]   sampling    Sampling connection
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_sampling(dev: *mut bladerf, sampling: bladerf_sampling)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the current RX Mux mode
 *
 * @param       dev     Device handle
 * @param       mux     Mux mode.
 *
 * @returns 0 on success, value from \ref RETCODES list on failure.
 */
    pub fn bladerf_set_rx_mux(dev: *mut bladerf, mux: bladerf_rx_mux)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Gets the current RX Mux mode
 *
 * @param[in]   dev     Device handle
 * @param[out]  mode    Current RX Mux mode
 *
 * @returns 0 on success, value from \ref RETCODES list on failure.
 */
    pub fn bladerf_get_rx_mux(dev: *mut bladerf, mode: *mut bladerf_rx_mux)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read the device's current state of RXVGA2 and ADC pin connection
 * to figure out which sampling mode it is currently configured in.
 *
 * @param[in]   dev         Device handle
 * @param[out]  sampling    Sampling connection
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_sampling(dev: *mut bladerf,
                                sampling: *mut bladerf_sampling)
     -> ::std::os::raw::c_int;
}
pub const BLADERF_LPF_NORMAL: _bindgen_ty_13 =
    _bindgen_ty_13::BLADERF_LPF_NORMAL;
pub const BLADERF_LPF_BYPASSED: _bindgen_ty_13 =
    _bindgen_ty_13::BLADERF_LPF_BYPASSED;
pub const BLADERF_LPF_DISABLED: _bindgen_ty_13 =
    _bindgen_ty_13::BLADERF_LPF_DISABLED;
#[repr(u32)]
/**
 * Low-Pass Filter (LPF) mode
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_13 {
    BLADERF_LPF_NORMAL = 0,
    BLADERF_LPF_BYPASSED = 1,
    BLADERF_LPF_DISABLED = 2,
}
pub use self::_bindgen_ty_13 as bladerf_lpf_mode;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the bandwidth of the LMS LPF to specified value in Hz
 *
 * The underlying device is capable of a discrete set of bandwidth values. The
 * caller should check the `actual` parameter to determine which of these
 * discrete bandwidth values is actually used for the requested bandwidth.
 *
 * Values outside the range of
 * [ \ref BLADERF_BANDWIDTH_MIN, \ref BLADERF_BANDWIDTH_MAX ]
 * will be clamped.
 *
 * @param[in]   dev                 Device handle
 * @param[in]   module              Module for bandwidth request
 * @param[in]   bandwidth           Desired bandwidth
 * @param[out]  actual              If non-NULL, written with the actual
 *                                  bandwidth that the device was able to
 *                                  achieve.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_bandwidth(dev: *mut bladerf, module: bladerf_module,
                                 bandwidth: ::std::os::raw::c_uint,
                                 actual: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get the bandwidth of the LMS LPF
 *
 * @param       dev                 Device Handle
 * @param       module              Module for bandwidth request
 * @param       bandwidth           Actual bandwidth in Hz
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_bandwidth(dev: *mut bladerf, module: bladerf_module,
                                 bandwidth: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the LMS LPF mode to bypass or disable it
 *
 * @param       dev         Device handle
 * @param       module      Module for mode request
 * @param       mode        Mode to be set
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_lpf_mode(dev: *mut bladerf, module: bladerf_module,
                                mode: bladerf_lpf_mode)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get the current mode of the LMS LPF
 *
 * @param       dev         Device handle
 * @param       module      Module for mode request
 * @param       mode        Current mode of the LPF
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_lpf_mode(dev: *mut bladerf, module: bladerf_module,
                                mode: *mut bladerf_lpf_mode)
     -> ::std::os::raw::c_int;
}
pub const BLADERF_TUNING_MODE_INVALID: _bindgen_ty_14 =
    _bindgen_ty_14::BLADERF_TUNING_MODE_INVALID;
pub const BLADERF_TUNING_MODE_HOST: _bindgen_ty_14 =
    _bindgen_ty_14::BLADERF_TUNING_MODE_HOST;
pub const BLADERF_TUNING_MODE_FPGA: _bindgen_ty_14 =
    _bindgen_ty_14::BLADERF_TUNING_MODE_FPGA;
#[repr(i32)]
/**
 * Frequency tuning modes
 *
 * BLADERF_TUNING_MODE_HOST is the default if either of the following conditions
 * are true:
 *   - libbladeRF < v1.3.0
 *   - FPGA       < v0.2.0
 *
 * BLADERF_TUNING_MODE_FPGA is the default if both of the following conditions
 * are true:
 *  - libbladeRF >= v1.3.0
 *  - FPGA       >= v0.2.0
 *
 * The default mode can be overridden by setting a BLADERF_DEFAULT_TUNING_MODE
 * environment variable to "host" or "fpga". Overriding this value with a mode
 * not supported by the FPGA will result in failures or unexpected behavior.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_14 {
    BLADERF_TUNING_MODE_INVALID = -1,
    BLADERF_TUNING_MODE_HOST = 0,
    BLADERF_TUNING_MODE_FPGA = 1,
}
pub use self::_bindgen_ty_14 as bladerf_tuning_mode;
/**
 * Quick Re-tune parameters. Note that these parameters, which are associated
 * with LMS6002D register values, are sensitive to changes in the operating
 * environment (e.g., temperature).
 *
 * This structure should be filled in via bladerf_get_quick_tune().
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bladerf_quick_tune {
    /**< Choice of VCO and VCO division factor */
    pub freqsel: u8,
    /**< VCOCAP value */
    pub vcocap: u8,
    /**< Integer portion of LO frequency value */
    pub nint: u16,
    /**< Fractional portion of LO frequency value */
    pub nfrac: u32,
    /**< Flag bits used internally by libbladeRF */
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_bladerf_quick_tune() {
    assert_eq!(::std::mem::size_of::<bladerf_quick_tune>() , 12usize);
    assert_eq!(::std::mem::align_of::<bladerf_quick_tune>() , 4usize);
}
impl Clone for bladerf_quick_tune {
    fn clone(&self) -> Self { *self }
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Select the appropriate band path given a frequency in Hz.
 *
 * Most API users will not need to use this function, as bladerf_set_frequency()
 * calls this internally after tuning the device.
 *
 * The high band (LNA2 and PA2) is used for `frequency` >= 1.5 GHz. Otherwise,
 * The low band (LNA1 and PA1) is used.
 *
 * Frequency values outside the range of
 * [ \ref BLADERF_FREQUENCY_MIN, \ref BLADERF_FREQUENCY_MAX ]
 * will be clamped.
 *
 * @param       dev         Device handle
 * @param       module      Module to configure
 * @param       frequency   Tuned frequency
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_select_band(dev: *mut bladerf, module: bladerf_module,
                               frequency: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set module's frequency in Hz.
 *
 * Values outside the range of
 * [ \ref BLADERF_FREQUENCY_MIN, \ref BLADERF_FREQUENCY_MAX ]
 * will be clamped.
 *
 * For best results, it is recommended to keep the RX and TX frequencies at
 * least 1 MHz apart, and to digitally mix on the RX side if reception closer
 * to the TX frequency is required.
 *
 * This calls bladerf_select_band() internally.
 *
 * @param       dev         Device handle
 * @param       module      Module to configure
 * @param       frequency   Desired frequency
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_frequency(dev: *mut bladerf, module: bladerf_module,
                                 frequency: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Schedule a frequency retune to occur at specified sample timestamp value.
 *
 * @pre bladerf_sync_config() must have been called with the
 *      BLADERF_FORMAT_SC16_Q11_META format for the associated module in order
 *      to enable timestamps. (The timestamped metadata format must be enabled
 *      in order to use this function.)
 *
 * @param       dev             Device handle
 *
 * @param       module          Module to retune
 *
 * @param       timestamp       Module's sample timestamp to perform the retune
 *                              operation. If this value is in the past, the
 *                              retune will occur immediately. To perform the
 *                              retune immediately, specify BLADERF_RETUNE_NOW.
 *
 * @param       frequency       Desired frequency, in Hz.
 *
 * @param       quick_tune      If NULL, the `frequency` parameter will be used.
 *                              If non-NULL, the provided "quick retune" values
 *                              will be applied to the transceiver to tune it
 *                              according to a previous state retrieved via
 *                              bladerf_get_quick_tune().
 *
 *
 * @return 0 on success, value from \ref RETCODES list on failure. If the
 *         underlying queue of scheduled retune requests becomes full,
 *         BLADERF_ERR_QUEUE_FULL will be returned. In this case, it should be
 *         possible to schedule a retune after the timestamp of one of the
 *         earlier requests occurs.
 */
    pub fn bladerf_schedule_retune(dev: *mut bladerf, module: bladerf_module,
                                   timestamp: u64,
                                   frequency: ::std::os::raw::c_uint,
                                   quick_tune: *mut bladerf_quick_tune)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Cancel all pending scheduled retune operations for the specified module.
 *
 * This will be done automatically during bladerf_close() to ensure that
 * previously queued retunes do not continue to occur after closing and then
 * later re-opening a device.
 *
 * @param   dev     Device handle
 * @param   module  Module to cancel pending operations on
 *
 * @return 0 on success, value from \ref RETCODES list on failure.
 */
    pub fn bladerf_cancel_scheduled_retunes(dev: *mut bladerf,
                                            module: bladerf_module)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get module's current frequency in Hz
 *
 * @param       dev         Device handle
 * @param       module      Module to configure
 * @param       frequency   Pointer to the returned frequency
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_frequency(dev: *mut bladerf, module: bladerf_module,
                                 frequency: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Fetch parameters used to tune the transceiver to the current frequency for
 * use with bladerf_schedule_retune() to perform a "quick retune."
 *
 * This allows for a faster retune, with a potential trade off of
 * increased phase noise.  Note that these parameters are sensitive to
 * changes in the operating environment, and should be "refreshed" if planning
 * to use the "quick retune" functionality over a long period of time.
 *
 * @pre bladerf_set_frequency() or bladerf_schedule_retune() have previously
 *      been used to retune to the desired frequency.
 *
 * @param[in]   dev         Device handle
 * @param[in]   module      Module to query
 * @param[out]  quick_tune  Quick retune parameters
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_quick_tune(dev: *mut bladerf, module: bladerf_module,
                                  quick_tune: *mut bladerf_quick_tune)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the device's tuning mode
 *
 * @param       dev         Device handle
 * @param       mode        Desired tuning mode. Note that the available modes
 *                          depends on the FPGA version.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_tuning_mode(dev: *mut bladerf,
                                   mode: bladerf_tuning_mode)
     -> ::std::os::raw::c_int;
}
pub const BLADERF_LB_FIRMWARE: _bindgen_ty_15 =
    _bindgen_ty_15::BLADERF_LB_FIRMWARE;
pub const BLADERF_LB_BB_TXLPF_RXVGA2: _bindgen_ty_15 =
    _bindgen_ty_15::BLADERF_LB_BB_TXLPF_RXVGA2;
pub const BLADERF_LB_BB_TXVGA1_RXVGA2: _bindgen_ty_15 =
    _bindgen_ty_15::BLADERF_LB_BB_TXVGA1_RXVGA2;
pub const BLADERF_LB_BB_TXLPF_RXLPF: _bindgen_ty_15 =
    _bindgen_ty_15::BLADERF_LB_BB_TXLPF_RXLPF;
pub const BLADERF_LB_BB_TXVGA1_RXLPF: _bindgen_ty_15 =
    _bindgen_ty_15::BLADERF_LB_BB_TXVGA1_RXLPF;
pub const BLADERF_LB_RF_LNA1: _bindgen_ty_15 =
    _bindgen_ty_15::BLADERF_LB_RF_LNA1;
pub const BLADERF_LB_RF_LNA2: _bindgen_ty_15 =
    _bindgen_ty_15::BLADERF_LB_RF_LNA2;
pub const BLADERF_LB_RF_LNA3: _bindgen_ty_15 =
    _bindgen_ty_15::BLADERF_LB_RF_LNA3;
pub const BLADERF_LB_NONE: _bindgen_ty_15 = _bindgen_ty_15::BLADERF_LB_NONE;
#[repr(u32)]
/**
 * Loopback options
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_15 {
    BLADERF_LB_FIRMWARE = 1,
    BLADERF_LB_BB_TXLPF_RXVGA2 = 2,
    BLADERF_LB_BB_TXVGA1_RXVGA2 = 3,
    BLADERF_LB_BB_TXLPF_RXLPF = 4,
    BLADERF_LB_BB_TXVGA1_RXLPF = 5,
    BLADERF_LB_RF_LNA1 = 6,
    BLADERF_LB_RF_LNA2 = 7,
    BLADERF_LB_RF_LNA3 = 8,
    BLADERF_LB_NONE = 9,
}
pub use self::_bindgen_ty_15 as bladerf_loopback;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Apply specified loopback mode
 *
 * @param       dev     Device handle
 * @param       l       Loopback mode. Note that BLADERF_LB_NONE disables the
 *                      use of loopback functionality.
 *
 * @note Loopback modes should only be enabled or disabled while the RX and TX
 *       modules are both disabled (and therefore, when no samples are being
 *       actively streamed). Otherwise, unexpected behavior may occur.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_loopback(dev: *mut bladerf, l: bladerf_loopback)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get current loopback mode
 *
 * @param[in]   dev     Device handle
 * @param[out]  l       Current loopback mode
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_loopback(dev: *mut bladerf, l: *mut bladerf_loopback)
     -> ::std::os::raw::c_int;
}
pub const BLADERF_SMB_MODE_INVALID: _bindgen_ty_16 =
    _bindgen_ty_16::BLADERF_SMB_MODE_INVALID;
pub const BLADERF_SMB_MODE_DISABLED: _bindgen_ty_16 =
    _bindgen_ty_16::BLADERF_SMB_MODE_DISABLED;
pub const BLADERF_SMB_MODE_OUTPUT: _bindgen_ty_16 =
    _bindgen_ty_16::BLADERF_SMB_MODE_OUTPUT;
pub const BLADERF_SMB_MODE_INPUT: _bindgen_ty_16 =
    _bindgen_ty_16::BLADERF_SMB_MODE_INPUT;
pub const BLADERF_SMB_MODE_UNAVAILBLE: _bindgen_ty_16 =
    _bindgen_ty_16::BLADERF_SMB_MODE_UNAVAILBLE;
#[repr(i32)]
/**
 * SMB clock port mode of operation
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_16 {
    BLADERF_SMB_MODE_INVALID = -1,
    BLADERF_SMB_MODE_DISABLED = 0,
    BLADERF_SMB_MODE_OUTPUT = 1,
    BLADERF_SMB_MODE_INPUT = 2,
    BLADERF_SMB_MODE_UNAVAILBLE = 3,
}
pub use self::_bindgen_ty_16 as bladerf_smb_mode;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the current mode of operation of the SMB clock port
 *
 * In a MIMO configuration, one "master" device should first be configured to
 * output its reference clock to the slave devices via
 * `bladerf_set_smb_mode(dev, BLADERF_SMB_MODE_OUTPUT)`.
 *
 * Next, all "slave" devices should be configured to use the reference clock
 * provided on the SMB clock port (instead of using their on-board reference)
 * via `bladerf_set_smb_mode(dev, BLADERF_SMB_MODE_INPUT)`.
 *
 * @param[in]   dev         Device handle
 * @param[in]   mode        Desired mode
 *
 * @return 0 on success, or a value from \ref RETCODES list on failure.
 */
    pub fn bladerf_set_smb_mode(dev: *mut bladerf, mode: bladerf_smb_mode)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get the current mode of operation of the SMB clock port
 *
 * @param[in]   dev         Device handle
 * @param[out]  mode        Desired mode
 *
 * @return 0 on success, or a value from \ref RETCODES list on failure.
 */
    pub fn bladerf_get_smb_mode(dev: *mut bladerf,
                                mode: *mut bladerf_smb_mode)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the SMB clock port frequency in rational Hz
 *
 * @param[in]   dev         Device handle
 * @param[in]   rate        Rational frequency
 * @param[out]  actual      If non-NULL, this is written with the actual
 *
 * The frequency must be between \ref BLADERF_SMB_FREQUENCY_MIN and
 * \ref BLADERF_SMB_FREQUENCY_MAX.
 *
 * This function inherently configures the SMB clock port as an output. Do not
 * call bladerf_set_smb_mode() with ::BLADERF_SMB_MODE_OUTPUT, as this will
 * reset the output frequency to the 38.4 MHz reference.
 *
 * @warning This clock should not be set if an expansion board is connected.
 *
 * @return 0 on success,
 *         BLADERF_ERR_INVAL for an invalid frequency,
 *         or a value from \ref RETCODES list on failure.
 */
    pub fn bladerf_set_rational_smb_frequency(dev: *mut bladerf,
                                              rate:
                                                  *mut bladerf_rational_rate,
                                              actual:
                                                  *mut bladerf_rational_rate)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the SMB connector output frequency in Hz.
 * Use bladerf_set_rational_smb_frequency() for more arbitrary values.
 *
 * @param[in]   dev         Device handle
 * @param[in]   rate        Frequency
 * @param[out]  actual      If non-NULL. this is written with the actual
 *                          frequency achieved.
 *
 * This function inherently configures the SMB clock port as an output. Do not
 * call bladerf_set_smb_mode() with ::BLADERF_SMB_MODE_OUTPUT, as this will
 * reset the output frequency to the 38.4 MHz reference.
 *
 * The frequency must be between \ref BLADERF_SMB_FREQUENCY_MIN and
 * \ref BLADERF_SMB_FREQUENCY_MAX.
 *
 * @warning This clock should not be set if an expansion board is connected.
 *
 * @return 0 on success,
 *         BLADERF_ERR_INVAL for an invalid frequency,
 *         or a value from \ref RETCODES list on other failures
 */
    pub fn bladerf_set_smb_frequency(dev: *mut bladerf, rate: u32,
                                     actual: *mut u32)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read the SMB connector output frequency in rational Hz
 *
 * @param[in]   dev         Device handle
 * @param[out]  rate        Pointer to returned rational frequency
 *
 * @return 0 on success, value from \ref RETCODES list upon failure
 */
    pub fn bladerf_get_rational_smb_frequency(dev: *mut bladerf,
                                              rate:
                                                  *mut bladerf_rational_rate)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read the SMB connector output frequency in Hz
 *
 * @param[in]   dev         Device handle
 * @param[out]  rate        Pointer to returned frequency
 *
 * @return 0 on success, value from \ref RETCODES list upon failure
 */
    pub fn bladerf_get_smb_frequency(dev: *mut bladerf,
                                     rate: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub const BLADERF_TRIGGER_ROLE_INVALID: _bindgen_ty_17 =
    _bindgen_ty_17::BLADERF_TRIGGER_ROLE_INVALID;
pub const BLADERF_TRIGGER_ROLE_DISABLED: _bindgen_ty_17 =
    _bindgen_ty_17::BLADERF_TRIGGER_ROLE_DISABLED;
pub const BLADERF_TRIGGER_ROLE_MASTER: _bindgen_ty_17 =
    _bindgen_ty_17::BLADERF_TRIGGER_ROLE_MASTER;
pub const BLADERF_TRIGGER_ROLE_SLAVE: _bindgen_ty_17 =
    _bindgen_ty_17::BLADERF_TRIGGER_ROLE_SLAVE;
#[repr(i32)]
/**
 * This value denotes the role of a device in a trigger chain.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_17 {
    BLADERF_TRIGGER_ROLE_INVALID = -1,
    BLADERF_TRIGGER_ROLE_DISABLED = 0,
    BLADERF_TRIGGER_ROLE_MASTER = 1,
    BLADERF_TRIGGER_ROLE_SLAVE = 2,
}
pub use self::_bindgen_ty_17 as bladerf_trigger_role;
pub const BLADERF_TRIGGER_INVALID: _bindgen_ty_18 =
    _bindgen_ty_18::BLADERF_TRIGGER_INVALID;
pub const BLADERF_TRIGGER_J71_4: _bindgen_ty_18 =
    _bindgen_ty_18::BLADERF_TRIGGER_J71_4;
pub const BLADERF_TRIGGER_USER_0: _bindgen_ty_18 =
    _bindgen_ty_18::BLADERF_TRIGGER_USER_0;
pub const BLADERF_TRIGGER_USER_1: _bindgen_ty_18 =
    _bindgen_ty_18::BLADERF_TRIGGER_USER_1;
pub const BLADERF_TRIGGER_USER_2: _bindgen_ty_18 =
    _bindgen_ty_18::BLADERF_TRIGGER_USER_2;
pub const BLADERF_TRIGGER_USER_3: _bindgen_ty_18 =
    _bindgen_ty_18::BLADERF_TRIGGER_USER_3;
pub const BLADERF_TRIGGER_USER_4: _bindgen_ty_18 =
    _bindgen_ty_18::BLADERF_TRIGGER_USER_4;
pub const BLADERF_TRIGGER_USER_5: _bindgen_ty_18 =
    _bindgen_ty_18::BLADERF_TRIGGER_USER_5;
pub const BLADERF_TRIGGER_USER_6: _bindgen_ty_18 =
    _bindgen_ty_18::BLADERF_TRIGGER_USER_6;
pub const BLADERF_TRIGGER_USER_7: _bindgen_ty_18 =
    _bindgen_ty_18::BLADERF_TRIGGER_USER_7;
#[repr(i32)]
/**
 * Trigger signal selection
 *
 * This selects pin or signal used for the trigger.
 *
 * ::BLADERF_TRIGGER_J71_4 is the only valid option as of FPGA v0.6.0.
 *
 * The BLADERF_TRIGGER_USER_* values have been added to allow users to modify
 * both hardware and software implementations to add custom triggers, while
 * maintaining libbladeRF API compatibility. Official bladeRF releases will
 * not utilize these user signal IDs.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_18 {
    BLADERF_TRIGGER_INVALID = -1,
    BLADERF_TRIGGER_J71_4 = 0,
    BLADERF_TRIGGER_USER_0 = 128,
    BLADERF_TRIGGER_USER_1 = 129,
    BLADERF_TRIGGER_USER_2 = 130,
    BLADERF_TRIGGER_USER_3 = 131,
    BLADERF_TRIGGER_USER_4 = 132,
    BLADERF_TRIGGER_USER_5 = 133,
    BLADERF_TRIGGER_USER_6 = 134,
    BLADERF_TRIGGER_USER_7 = 135,
}
pub use self::_bindgen_ty_18 as bladerf_trigger_signal;
/**
 * Trigger configuration
 *
 * It is <b>highly recommended</b> to keep a 1:1 relationship between triggers
 * in the physical setup and instances of this structure. (i.e., do not
 * re-use and change the same bladerf_trigger) for multiple triggers.)
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bladerf_trigger {
    /**< RX/TX module associated with trigger */
    pub module: bladerf_module,
    /**< Role of the device in a trigger chain */
    pub role: bladerf_trigger_role,
    /**< Pin or signal being used */
    pub signal: bladerf_trigger_signal,
    /**< Reserved field for future options. This
                                    *   is unused and should be set to 0.
                                    */
    pub options: u64,
}
#[test]
fn bindgen_test_layout_bladerf_trigger() {
    assert_eq!(::std::mem::size_of::<bladerf_trigger>() , 24usize);
    assert_eq!(::std::mem::align_of::<bladerf_trigger>() , 8usize);
}
impl Clone for bladerf_trigger {
    fn clone(&self) -> Self { *self }
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Initialize a bladerf_trigger structure based upon the current configuration
 * of the specified trigger signal.
 *
 * While it is possible to simply declare and manually fill in a
 * bladerf_trigger structure, it is recommended to use this function to
 * retrieve the current `role` and `options` values.
 *
 * @param[in]   dev         Device to query
 * @param[in]   module      Module to query
 * @param[in]   signal      Trigger signal to query
 * @param[out]  trigger     Updated to describe trigger
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_trigger_init(dev: *mut bladerf, module: bladerf_module,
                                signal: bladerf_trigger_signal,
                                trigger: *mut bladerf_trigger)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Configure and (dis)arm a trigger on the specified device.
 *
 * @note If trigger->role is set to ::BLADERF_TRIGGER_ROLE_DISABLED,
 *       this will inherently disarm an armed trigger and clear any fire
 *       requests, regardless of the value of `arm`.
 *
 * @param[in]   dev     Device to configure
 * @param[in]   trigger Trigger configure
 * @param[in]   arm     (Re)Arm trigger if true, disarm if false
 * @param[in]   resv1   Reserved for future use. Set to 0.
 * @param[in]   resv2   Reserved for future use. Set to 0.
 *
 * @warning Configuring two devices in the trigger chain (or both RX and
 *          TX on a single device) as masters can damage the associated FPGA
 *          pins, as this would cause contention over the trigger signal.<b>
 *          Ensure only one device in the chain is configured as the master!
 *          </b>
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_trigger_arm(dev: *mut bladerf,
                               trigger: *const bladerf_trigger, arm: bool,
                               resv1: u64, resv2: u64)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Fire a trigger event.
 *
 * Calling this functiona with a trigger whose role is anything other than
 * ::BLADERF_TRIGGER_REG_MASTER will yield a BLADERF_ERR_INVAL return value.
 *
 * @param[in]   dev         Device handle
 * @param[in]   trigger     Trigger to assert
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_trigger_fire(dev: *mut bladerf,
                                trigger: *const bladerf_trigger)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Query the fire request status of a master trigger
 *
 * @param[in]   dev             Device handle
 *
 * @param[in]   trigger         Trigger to query
 *
 * @param[out]  is_armed        Set to true if the trigger is armed, and false
 *                              otherwise. May be NULL.
 *
 * @param[out]  has_fired       Set to true if the trigger has fired, and false
 *                              otherwise. May be NULL.
 *
 * @param[out]  fire_requested  Only applicable to a trigger master.
 *                              Set to true if a fire request has been
 *                              previously submitted. May be NULL.
 *
 * @param[out]  resv1           Reserved for future use.
 *                              This field is written as 0 if not set to NULL.
 *
 * @param[out]  resv2           Reserved for future use.
 *                              This field is written as 0 if not set to NULL.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_trigger_state(dev: *mut bladerf,
                                 trigger: *const bladerf_trigger,
                                 is_armed: *mut bool, has_fired: *mut bool,
                                 fire_requested: *mut bool, resv1: *mut u64,
                                 resv2: *mut u64) -> ::std::os::raw::c_int;
}
pub const BLADERF_DC_CAL_INVALID: _bindgen_ty_19 =
    _bindgen_ty_19::BLADERF_DC_CAL_INVALID;
pub const BLADERF_DC_CAL_LPF_TUNING: _bindgen_ty_19 =
    _bindgen_ty_19::BLADERF_DC_CAL_LPF_TUNING;
pub const BLADERF_DC_CAL_TX_LPF: _bindgen_ty_19 =
    _bindgen_ty_19::BLADERF_DC_CAL_TX_LPF;
pub const BLADERF_DC_CAL_RX_LPF: _bindgen_ty_19 =
    _bindgen_ty_19::BLADERF_DC_CAL_RX_LPF;
pub const BLADERF_DC_CAL_RXVGA2: _bindgen_ty_19 =
    _bindgen_ty_19::BLADERF_DC_CAL_RXVGA2;
#[repr(i32)]
/**
 * DC Calibration Modules
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_19 {
    BLADERF_DC_CAL_INVALID = -1,
    BLADERF_DC_CAL_LPF_TUNING = 0,
    BLADERF_DC_CAL_TX_LPF = 1,
    BLADERF_DC_CAL_RX_LPF = 2,
    BLADERF_DC_CAL_RXVGA2 = 3,
}
pub use self::_bindgen_ty_19 as bladerf_cal_module;
pub const BLADERF_CORR_LMS_DCOFF_I: _bindgen_ty_20 =
    _bindgen_ty_20::BLADERF_CORR_LMS_DCOFF_I;
pub const BLADERF_CORR_LMS_DCOFF_Q: _bindgen_ty_20 =
    _bindgen_ty_20::BLADERF_CORR_LMS_DCOFF_Q;
pub const BLADERF_CORR_FPGA_PHASE: _bindgen_ty_20 =
    _bindgen_ty_20::BLADERF_CORR_FPGA_PHASE;
pub const BLADERF_CORR_FPGA_GAIN: _bindgen_ty_20 =
    _bindgen_ty_20::BLADERF_CORR_FPGA_GAIN;
#[repr(u32)]
/**
 * Correction parameter selection
 *
 * These values specify the correction parameter to modify or query when
 * calling bladerf_set_correction() or bladerf_get_correction(). Note that the
 * meaning of the `value` parameter to these functions depends upon the
 * correction parameter.
 *
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_20 {
    BLADERF_CORR_LMS_DCOFF_I = 0,
    BLADERF_CORR_LMS_DCOFF_Q = 1,
    BLADERF_CORR_FPGA_PHASE = 2,
    BLADERF_CORR_FPGA_GAIN = 3,
}
pub use self::_bindgen_ty_20 as bladerf_correction;
pub const BLADERF_VCTCXO_TAMER_INVALID: _bindgen_ty_21 =
    _bindgen_ty_21::BLADERF_VCTCXO_TAMER_INVALID;
pub const BLADERF_VCTCXO_TAMER_DISABLED: _bindgen_ty_21 =
    _bindgen_ty_21::BLADERF_VCTCXO_TAMER_DISABLED;
pub const BLADERF_VCTCXO_TAMER_1_PPS: _bindgen_ty_21 =
    _bindgen_ty_21::BLADERF_VCTCXO_TAMER_1_PPS;
pub const BLADERF_VCTCXO_TAMER_10_MHZ: _bindgen_ty_21 =
    _bindgen_ty_21::BLADERF_VCTCXO_TAMER_10_MHZ;
#[repr(i32)]
/**
 * VCTCXO Tamer mode selection
 *
 * These values control the use of header J71 pin 1 for taming the
 * on-board VCTCXO to improve or sustain frequency accuracy.
 *
 * When supplying input into the VCTCXO tamer, a 1.8V signal must be provided.
 *
 * <b>
 * IMPORTANT: Exceeding 1.8V on J71-1 can damage the associated FPGA I/O bank.
 * Ensure that you provide only a 1.8V signal!
 * </b>
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_21 {
    BLADERF_VCTCXO_TAMER_INVALID = -1,
    BLADERF_VCTCXO_TAMER_DISABLED = 0,
    BLADERF_VCTCXO_TAMER_1_PPS = 1,
    BLADERF_VCTCXO_TAMER_10_MHZ = 2,
}
pub use self::_bindgen_ty_21 as bladerf_vctcxo_tamer_mode;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the value of the specified configuration parameter
 *
 * See the ::bladerf_correction description for the valid ranges of the
 * `value` parameter.
 *
 * @param   dev         Device handle
 * @param   module      Module to apply correction to
 * @param   corr        Correction type
 * @param   value       Value to apply
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_correction(dev: *mut bladerf, module: bladerf_module,
                                  corr: bladerf_correction, value: i16)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Obtain the current value of the specified configuration parameter
 *
 * @param[in]   dev         Device handle
 * @param[in]   module      Module to retrieve correction information from
 * @param[in]   corr        Correction type
 * @param[out]  value       Current value
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_correction(dev: *mut bladerf, module: bladerf_module,
                                  corr: bladerf_correction, value: *mut i16)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set the VCTCXO tamer mode.
 *
 * @param       dev         Device handle
 * @param       mode        VCTCXO taming mode
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_vctcxo_tamer_mode(dev: *mut bladerf,
                                         mode: bladerf_vctcxo_tamer_mode)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get the current VCTCXO tamer mode
 *
 * @param[in]       dev         Device handle
 * @param[out]      mode        Current VCTCXO taming mode or
 *                              BLADERF_VCTCXO_TAMER_INVALID if a failure
 *                              occurs.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_vctcxo_tamer_mode(dev: *mut bladerf,
                                         mode: *mut bladerf_vctcxo_tamer_mode)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write value to VCTCXO trim DAC.
 *
 * This should not be used when the VCTCXO tamer is enabled.
 *
 * @param   dev         Device handle
 * @param   val         Value to write to VCTCXO trim DAC
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_dac_write(dev: *mut bladerf, val: u16)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read value from VCTCXO trim DAC.
 *
 * This is similar to bladerf_get_vctcxo_trim(), except that it returns the
 * current trim DAC value, as opposed to the calibration value read from
 * flash.
 *
 * Use this if you are trying to query the value after having previously
 * made calls to bladerf_dac_write().
 *
 * @param[in]   dev     Device handle
 * @param[out]  val     Value to read from VCTCXO trim DAC
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_dac_read(dev: *mut bladerf, val: *mut u16)
     -> ::std::os::raw::c_int;
}
pub const BLADERF_XB_NONE: _bindgen_ty_22 = _bindgen_ty_22::BLADERF_XB_NONE;
pub const BLADERF_XB_100: _bindgen_ty_22 = _bindgen_ty_22::BLADERF_XB_100;
pub const BLADERF_XB_200: _bindgen_ty_22 = _bindgen_ty_22::BLADERF_XB_200;
pub const BLADERF_XB_300: _bindgen_ty_22 = _bindgen_ty_22::BLADERF_XB_300;
#[repr(u32)]
/**
 * Expansion boards
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_22 {
    BLADERF_XB_NONE = 0,
    BLADERF_XB_100 = 1,
    BLADERF_XB_200 = 2,
    BLADERF_XB_300 = 3,
}
pub use self::_bindgen_ty_22 as bladerf_xb;
pub const BLADERF_XB200_50M: _bindgen_ty_23 =
    _bindgen_ty_23::BLADERF_XB200_50M;
pub const BLADERF_XB200_144M: _bindgen_ty_23 =
    _bindgen_ty_23::BLADERF_XB200_144M;
pub const BLADERF_XB200_222M: _bindgen_ty_23 =
    _bindgen_ty_23::BLADERF_XB200_222M;
pub const BLADERF_XB200_CUSTOM: _bindgen_ty_23 =
    _bindgen_ty_23::BLADERF_XB200_CUSTOM;
pub const BLADERF_XB200_AUTO_1DB: _bindgen_ty_23 =
    _bindgen_ty_23::BLADERF_XB200_AUTO_1DB;
pub const BLADERF_XB200_AUTO_3DB: _bindgen_ty_23 =
    _bindgen_ty_23::BLADERF_XB200_AUTO_3DB;
#[repr(u32)]
/**
 * XB-200 filter selection options
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_23 {
    BLADERF_XB200_50M = 0,
    BLADERF_XB200_144M = 1,
    BLADERF_XB200_222M = 2,
    BLADERF_XB200_CUSTOM = 3,
    BLADERF_XB200_AUTO_1DB = 4,
    BLADERF_XB200_AUTO_3DB = 5,
}
pub use self::_bindgen_ty_23 as bladerf_xb200_filter;
pub const BLADERF_XB200_BYPASS: _bindgen_ty_24 =
    _bindgen_ty_24::BLADERF_XB200_BYPASS;
pub const BLADERF_XB200_MIX: _bindgen_ty_24 =
    _bindgen_ty_24::BLADERF_XB200_MIX;
#[repr(u32)]
/**
 * XB-200 signal paths
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_24 { BLADERF_XB200_BYPASS = 0, BLADERF_XB200_MIX = 1, }
pub use self::_bindgen_ty_24 as bladerf_xb200_path;
pub const BLADERF_XB300_TRX_INVAL: _bindgen_ty_25 =
    _bindgen_ty_25::BLADERF_XB300_TRX_INVAL;
pub const BLADERF_XB300_TRX_TX: _bindgen_ty_25 =
    _bindgen_ty_25::BLADERF_XB300_TRX_TX;
pub const BLADERF_XB300_TRX_RX: _bindgen_ty_25 =
    _bindgen_ty_25::BLADERF_XB300_TRX_RX;
pub const BLADERF_XB300_TRX_UNSET: _bindgen_ty_25 =
    _bindgen_ty_25::BLADERF_XB300_TRX_UNSET;
#[repr(i32)]
/**
 * XB-300 TRX setting
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_25 {
    BLADERF_XB300_TRX_INVAL = -1,
    BLADERF_XB300_TRX_TX = 0,
    BLADERF_XB300_TRX_RX = 1,
    BLADERF_XB300_TRX_UNSET = 2,
}
pub use self::_bindgen_ty_25 as bladerf_xb300_trx;
pub const BLADERF_XB300_AMP_INVAL: _bindgen_ty_26 =
    _bindgen_ty_26::BLADERF_XB300_AMP_INVAL;
pub const BLADERF_XB300_AMP_PA: _bindgen_ty_26 =
    _bindgen_ty_26::BLADERF_XB300_AMP_PA;
pub const BLADERF_XB300_AMP_LNA: _bindgen_ty_26 =
    _bindgen_ty_26::BLADERF_XB300_AMP_LNA;
pub const BLADERF_XB300_AMP_PA_AUX: _bindgen_ty_26 =
    _bindgen_ty_26::BLADERF_XB300_AMP_PA_AUX;
#[repr(i32)]
/**
 * XB-300 Amplifier selection
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_26 {
    BLADERF_XB300_AMP_INVAL = -1,
    BLADERF_XB300_AMP_PA = 0,
    BLADERF_XB300_AMP_LNA = 1,
    BLADERF_XB300_AMP_PA_AUX = 2,
}
pub use self::_bindgen_ty_26 as bladerf_xb300_amplifier;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Attach and enable an expansion board's features
 *
 * @param       dev         Device handle
 * @param       xb          Expansion board
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_expansion_attach(dev: *mut bladerf, xb: bladerf_xb)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Determine which expansion board is attached
 *
 * @param       dev         Device handle
 * @param       xb          Expansion board
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_expansion_get_attached(dev: *mut bladerf,
                                          xb: *mut bladerf_xb)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set XB-200 filterbank
 *
 * @param       dev         Device handle
 * @param       mod         Module
 * @param       filter      XB200 filterbank
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_xb200_set_filterbank(dev: *mut bladerf,
                                        mod_: bladerf_module,
                                        filter: bladerf_xb200_filter)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get current XB-200 filterbank
 *
 * @param[in]    dev        Device handle
 * @param[in]    module     Module to query
 * @param[out]   filter     Pointer to filterbank, only updated if return
 *                          value is 0.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_xb200_get_filterbank(dev: *mut bladerf,
                                        module: bladerf_module,
                                        filter: *mut bladerf_xb200_filter)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set XB-200 signal path
 *
 * @param       dev         Device handle
 * @param       module      Module to configure
 * @param       path        Desired XB-200 signal path
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_xb200_set_path(dev: *mut bladerf, module: bladerf_module,
                                  path: bladerf_xb200_path)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get current XB-200 signal path
 *
 * @param       dev         Device handle
 * @param       module      Module to query
 * @param       path        Pointer to XB200 signal path
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_xb200_get_path(dev: *mut bladerf, module: bladerf_module,
                                  path: *mut bladerf_xb200_path)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Configure the XB-300 TRX path
 *
 * @param       dev         Device handle
 * @param       trx         Desired XB-300 TRX setting
 *
 * @return 0 on success, BLADERF_ERR_* on failure
 */
    pub fn bladerf_xb300_set_trx(dev: *mut bladerf, trx: bladerf_xb300_trx)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get the current XB-300 signal path
 *
 * @param       dev         Device handle
 * @param       trx         XB300 TRX antenna setting
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_xb300_get_trx(dev: *mut bladerf,
                                 trx: *mut bladerf_xb300_trx)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Enable or disable selected XB-300 amplifier
 *
 * @param       dev         Device handle
 * @param       amp         XB-300 amplifier
 * @param       enable      Set true to enable or false to disable
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_xb300_set_amplifier_enable(dev: *mut bladerf,
                                              amp: bladerf_xb300_amplifier,
                                              enable: bool)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get state of selected XB-300 amplifier
 *
 * @param       dev         Device handle
 * @param       amp         XB-300 amplifier
 * @param       enable      Set true to enable or false to disable
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_xb300_get_amplifier_enable(dev: *mut bladerf,
                                              amp: bladerf_xb300_amplifier,
                                              enable: *mut bool)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get current PA PDET output power in dBm
 *
 * @param       dev         Device handle
 * @param       val         Output power in dBm
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_xb300_get_output_power(dev: *mut bladerf, val: *mut f32)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read the state of expansion GPIO values
 *
 * @param[in]   dev         Device handle
 * @param[out]  val         Value of GPIO pins
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_expansion_gpio_read(dev: *mut bladerf, val: *mut u32)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write expansion GPIO pins.
 *
 * Callers should be sure to perform a read-modify-write sequence to avoid
 * accidentally clearing other GPIO bits that may be set by the library
 * internally.
 *
 * Consider using bladerf_expansion_gpio_masked_write() instead.
 *
 * @param   dev         Device handle
 * @param   val         Data to write to GPIO pins.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_expansion_gpio_write(dev: *mut bladerf, val: u32)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write values to the specified GPIO pins
 *
 * This function alleviates the need for the caller to perform a
 * read-modify-write sequence. The supplied mask is used by the FPGA to
 * perform the required RMW operation.
 *
 * @param   dev         Device handle
 * @param   mask        Mask of pins to write
 * @param   value       Value to write.
 *
 * For example, to set XB200 pins J16-1 and J16-2, and clear J16-4 and J16-5:
 * @code{.c}
 *  const uint32_t pins_to_write =
 *      BLADERF_XB200_PIN_J16_1 |
 *      BLADERF_XB200_PIN_J16_2 |
 *      BLADERF_XB200_PIN_J16_3 |
 *      BLADERF_XB200_PIN_J16_4;
 *
 *  const uint32_t values_to_write =
 *      BLADERF_XB200_PIN_J16_1 |
 *      BLADERF_XB200_PIN_J16_2;
 *
 *  int status = bladerf_expansion_gpio_masked_write(dev,
 *                                                   pins_to_write,
 *                                                   values_to_write);
 * @endcode
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_expansion_gpio_masked_write(dev: *mut bladerf, mask: u32,
                                               value: u32)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read the expansion GPIO direction register
 *
 * @param[in]   dev         Device handle
 * @param[out]  outputs     Pins configured as outputs will be set to '1'.
 *                          Pins configured as inputs will be set to '0'.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_expansion_gpio_dir_read(dev: *mut bladerf,
                                           outputs: *mut u32)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write to the expansion GPIO direction register.
 *
 * Callers should be sure to perform a read-modify-write sequence to avoid
 * accidentally clearing other GPIO bits that may be set by the library
 * internally.
 *
 * Consider using bladerf_expansion_gpio_dir_masked_write() instead.
 *
 * @param   dev         Device handle
 * @param   outputs     Pins set to '1' will be configured as outputs.
 *                      Pins set to '0' will be configured as inputs.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_expansion_gpio_dir_write(dev: *mut bladerf, outputs: u32)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Configure the direction of the specified expansion GPIO pins
 *
 * This function alleviates the need for the caller to perform a
 * read-modify-write sequence. The supplied mask is used by the FPGA to
 * perform the required RMW operation.
 *
 * @param   dev         Device handle
 * @param   mask        Bitmask of pins to configure
 * @param   outputs     Pins set to '1' will be configured as outputs.
 *                      Pins set to '0' will be configured as inputs.
 *
 * For example, to configure XB200 pins J16-1 and J16-2 and pins
 * J16-4 and J16-5 as inputs:
 *
 * @code{.c}
 *  const uint32_t pins_to_config =
 *      BLADERF_XB200_PIN_J16_1 |
 *      BLADERF_XB200_PIN_J16_2 |
 *      BLADERF_XB200_PIN_J16_3 |
 *      BLADERF_XB200_PIN_J16_4;
 *
 *  const uint32_t output_pins =
 *      BLADERF_XB200_PIN_J16_1 |
 *      BLADERF_XB200_PIN_J16_2;
 *
 *  int status = bladerf_expansion_gpio_masked_write(dev,
 *                                                   pins_to_config,
 *                                                   output_pins);
 * @endcode
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_expansion_gpio_dir_masked_write(dev: *mut bladerf,
                                                   mask: u32, outputs: u32)
     -> ::std::os::raw::c_int;
}
pub const BLADERF_LOG_LEVEL_VERBOSE: _bindgen_ty_27 =
    _bindgen_ty_27::BLADERF_LOG_LEVEL_VERBOSE;
pub const BLADERF_LOG_LEVEL_DEBUG: _bindgen_ty_27 =
    _bindgen_ty_27::BLADERF_LOG_LEVEL_DEBUG;
pub const BLADERF_LOG_LEVEL_INFO: _bindgen_ty_27 =
    _bindgen_ty_27::BLADERF_LOG_LEVEL_INFO;
pub const BLADERF_LOG_LEVEL_WARNING: _bindgen_ty_27 =
    _bindgen_ty_27::BLADERF_LOG_LEVEL_WARNING;
pub const BLADERF_LOG_LEVEL_ERROR: _bindgen_ty_27 =
    _bindgen_ty_27::BLADERF_LOG_LEVEL_ERROR;
pub const BLADERF_LOG_LEVEL_CRITICAL: _bindgen_ty_27 =
    _bindgen_ty_27::BLADERF_LOG_LEVEL_CRITICAL;
pub const BLADERF_LOG_LEVEL_SILENT: _bindgen_ty_27 =
    _bindgen_ty_27::BLADERF_LOG_LEVEL_SILENT;
#[repr(u32)]
/**
 * Severity levels for logging functions
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_27 {
    BLADERF_LOG_LEVEL_VERBOSE = 0,
    BLADERF_LOG_LEVEL_DEBUG = 1,
    BLADERF_LOG_LEVEL_INFO = 2,
    BLADERF_LOG_LEVEL_WARNING = 3,
    BLADERF_LOG_LEVEL_ERROR = 4,
    BLADERF_LOG_LEVEL_CRITICAL = 5,
    BLADERF_LOG_LEVEL_SILENT = 6,
}
pub use self::_bindgen_ty_27 as bladerf_log_level;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Retrieve the backend string associated with the specified
 * backend enumeration value.
 *
 * @warning Do not attempt to modify or free() the returned string.
 *
 * @return A string that can used to specify the `backend` portion of a device
 *         identifier string. (See bladerf_open().)
 */
    pub fn bladerf_backend_str(backend: bladerf_backend)
     -> *const ::std::os::raw::c_char;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get libbladeRF version information
 *
 * @param[out]  version     libbladeRF version information
 */
    pub fn bladerf_version(version: *mut bladerf_version);
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Sets the filter level for displayed log messages. Messages that are at or
 * above the specified log level will be printed, while messages with a lower
 * log level will be suppressed.
 *
 * @param   level       The new log level filter value
 */
    pub fn bladerf_log_set_verbosity(level: bladerf_log_level);
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read firmware log data and write it to the specified file
 *
 * @param   dev         Device to read firmware log from
 * @param   filename    Filename to write log information to. If set to NULL,
 *                      log data will be printed to stdout.
 *
 * @return 0 upon success, or a value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_fw_log(dev: *mut bladerf,
                              filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub const BLADERF_FORMAT_SC16_Q11: _bindgen_ty_28 =
    _bindgen_ty_28::BLADERF_FORMAT_SC16_Q11;
pub const BLADERF_FORMAT_SC16_Q11_META: _bindgen_ty_28 =
    _bindgen_ty_28::BLADERF_FORMAT_SC16_Q11_META;
#[repr(u32)]
/**
 * Sample format
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_28 {
    BLADERF_FORMAT_SC16_Q11 = 0,
    BLADERF_FORMAT_SC16_Q11_META = 1,
}
pub use self::_bindgen_ty_28 as bladerf_format;
/**
 * Sample metadata
 *
 * This structure is used in conjunction with the ::BLADERF_FORMAT_SC16_Q11_META
 * format to TX scheduled bursts or retrieve timestamp information about
 * received samples.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bladerf_metadata {
    /**
     * Free-running FPGA counter that monotonically increases at the
     * sample rate of the associated module. */
    pub timestamp: u64,
    /**
     * Input bit field to control the behavior of the call that the metadata
     * structure is passed to. API calls read this field from the provided
     * data structure, and do not modify it.
     *
     * Valid flags include
     *  ::BLADERF_META_FLAG_TX_BURST_START, ::BLADERF_META_FLAG_TX_BURST_END,
     *  ::BLADERF_META_FLAG_TX_NOW, ::BLADERF_META_FLAG_TX_UPDATE_TIMESTAMP,
     *  and ::BLADERF_META_FLAG_RX_NOW
     *
     */
    pub flags: u32,
    /**
     * Output bit field to denoting the status of transmissions/receptions. API
     * calls will write this field.
     *
     * Possible status flags include ::BLADERF_META_STATUS_OVERRUN and
     * ::BLADERF_META_STATUS_UNDERRUN;
     *
     */
    pub status: u32,
    /**
     * This output parameter is updated to reflect the actual number of
     * contiguous samples that have been populated in an RX buffer during
     * a bladerf_sync_rx() call.
     *
     * This will not be equal to the requested count in the event of a
     * discontinuity (i.e., when the status field has the
     * ::BLADERF_META_STATUS_OVERRUN flag set). When an overrun occurs, it is
     * important not to read past the number of samples specified by this
     * value, as the remaining contents of the buffer are undefined.
     *
     * This parameter is not currently used by bladerf_sync_tx().
     */
    pub actual_count: ::std::os::raw::c_uint,
    /**
     * Reserved for future use. This is not used by any functions.
     * It is recommended that users zero out this field.
     */
    pub reserved: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_bladerf_metadata() {
    assert_eq!(::std::mem::size_of::<bladerf_metadata>() , 56usize);
    assert_eq!(::std::mem::align_of::<bladerf_metadata>() , 8usize);
}
impl Clone for bladerf_metadata {
    fn clone(&self) -> Self { *self }
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Retrieve the specified module's current timestamp counter value from the
 * FPGA.
 *
 * This function is only intended to be used to retrieve a coarse estimate of
 * the current timestamp when starting up a stream. It <b>should not</b> be used
 * as a means to accurately retrieve the current timestamp of individual samples
 * within a running stream. The reasons for this are:
 *  - The timestamp counter will have advanced during the time that the captured
 *      value is propagated back from the FPGA to the host
 *  - The value retrieved in this manner is not tightly-coupled with
 *      specific sample positions in the stream.
 *
 * When actively receiving a sample stream, instead use the
 * ::bladerf_metadata::timestamp field (provided when using the
 * ::BLADERF_FORMAT_SC16_Q11_META format) to retrieve the timestamp value
 * associated with a block of samples. See the
 * <a class="el" href="sync_rx_meta.html">RX with metadata</a> page for
 * examples of this.
 *
 * An example use-case of this function is to schedule an initial TX burst
 * in a set of bursts;
 *  - Configure and start a TX stream using the ::BLADERF_FORMAT_SC16_Q11_META
 *      format.
 *  - Retrieve timestamp `T`, a coarse estimate the TX's current timestamp via this
 *      function.
 *  - Schedule the first burst, `F` to occur in the future: `F = T + N`.
 *      Generally, adding `N` in tens to low hundreds of milliseconds is
 *      sufficient to account for timestamp retrieval overhead and stream
 *      startup.
 *  - Schedule additional bursts relative to the first burst `F`.
 *
 * Examples of the above are shown on the <a class="el"
 * href="sync_tx_meta_bursts.html">TX with metadata</a> page.
 *
 * @param[in]   dev         Device handle
 * @param[in]   mod         Module to query
 * @param[out]  value       Coarse timestamp value
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_timestamp(dev: *mut bladerf, mod_: bladerf_module,
                                 value: *mut u64) -> ::std::os::raw::c_int;
}
/**
 * This typedef represents a callback function that is executed in response to
 * this interface's asynchronous events.
 *
 * Stream callbacks <b>must not</b> block or perform long-running operations.
 * Otherwise, timeouts may occur. If this cannot be guaranteed, consider
 * returning BLADERF_STREAM_NO_DATA in callbacks and later submit a buffer using
 * bladerf_submit_stream_buffer(). However, callbacks should always take a
 * single approach of returning buffers <b>or</b> returning
 * BLADERF_STREAM_NO_DATA and submitting buffers later -- <b>but not both</b>.
 *
 * When running in a full-duplex mode of operation with simultaneous TX and RX
 * stream threads, be aware that one module's callback may occur in the context
 * of another module's thread. The API user is responsible for ensuring their
 * callbacks are thread safe. For example, when managing access to sample
 * buffers, the caller must ensure that if one thread is processing samples in a
 * buffer, that this buffer is not returned via the callback's return value.
 *
 * As of libbladeRF v0.15.0, is guaranteed that only one callback from a module
 * will occur at a time. (i.e., a second TX callback will not fire while one is
 * currently being handled.)  To achieve this, while a callback is executing, a
 * per-stream lock is held. It is important to consider this when thinking about
 * the order of lock acquisitions both in the callbacks, and the code
 * surrounding bladerf_submit_stream_buffer().
 *
 * <b>Note:</b>Do not call bladerf_submit_stream_buffer() from a callback.
 *
 * For both RX and TX, the stream callback receives:
 *  - dev:          Device structure
 *  - stream:       The associated stream
 *  - metadata:     For future support - do not attempt to read/write this
 *                  in the current library implementation.
 *  - user_data:    User data provided when initializing stream
 *
 * For TX callbacks:
 *  - samples:      Pointer to buffer of samples that was sent
 *  - num_samples:  Number of sent in last transfer and to send in next transfer
 *  - Return value: The user specifies the address of the next buffer to send,
 *                  BLADERF_STREAM_SHUTDOWN, or BLADERF_STREAM_NO_DATA.
 *
 * For RX callbacks:
 *  - samples:          Buffer filled with received data
 *  - num_samples:      Number of samples received and size of next buffers
 *  - Return value:     The user specifies the next buffer to fill with RX data,
 *                      which should be `num_samples` in size,
 *                      BLADERF_STREAM_SHUTDOWN, or BLADERF_STREAM_NO_DATA.
 *
 */
pub type bladerf_stream_cb =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut bladerf,
                                               stream: *mut bladerf_stream,
                                               meta: *mut bladerf_metadata,
                                               samples:
                                                   *mut ::std::os::raw::c_void,
                                               num_samples: usize,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
#[link(name = "bladeRF")] extern "C" {
    /**
 * Initialize a stream for use with asynchronous routines.
 *
 * This function will internally allocate data buffers, which will be provided
 * to the API user in callback functions.
 *
 * The `buffers` output parameter populates a pointer to the list of allocated
 * buffers. This allows the API user to implement a buffer management scheme to
 * best suit his or her specific use case.
 *
 * Generally, one will want to set the `buffers` parameter to a value larger
 * than the `num_transfers` parameter, and keep track of which buffers are
 * currently "in-flight", versus those available for use.
 *
 * For example, for a transmit stream, modulated data can be actively written
 * into free buffers while transfers of other buffers are occurring. Once a
 * buffer has been filled with data, it can be marked 'in-flight' and be
 * returned in a successive callback to transmit.
 *
 * The choice of values for the `num_transfers` and `buffer_size` should be
 * made based upon the desired samplerate, and the stream timeout value
 * specified via bladerf_set_stream_timeout(), which defaults to 1 second.
 *
 * For a given sample rate, the below relationship must be upheld to transmit or
 * receive data without timeouts or dropped data.
 *
 * @f[
 * Sample\ Rate > \frac{\#\ Transfers}{Timeout} \times Buffer\ Size
 * @f]
 *
 * ...where Sample Rate is in samples per second, and Timeout is in seconds.
 *
 * To account for general system overhead, it is recommended to multiply the
 * righthand side by 1.1 to 1.25.
 *
 * While increasing the number of buffers available provides additional
 * elasticity, be aware that it also increases latency.
 *
 * @param[out]  stream          Upon success, this will be updated to contain
 *                              a stream handle (i.e., address)
 *
 * @param[in]   dev             Device to associate with the stream
 *
 * @param[in]   callback        Callback routine to handle asynchronous events
 *
 * @param[out]  buffers         This will be updated to point to a dynamically
 *                              allocated array of buffer pointers.
 *
 * @param[in]   num_buffers     Number of buffers to allocate and return. This
 *                              value must >= the `num_transfers` parameter.
 *
 * @param[in]   format          Sample data format
 *
 * @param[in]   samples_per_buffer  Size of allocated buffers, in units of
 *                                  samples Note that the physical size of the
 *                                  buffer is a function of this and the format
 *                                  parameter.
 *
 * @param[in]   num_transfers   Maximum number of transfers that may be
 *                              in-flight simultaneously. This must be <= the
 *                              `num_buffers` parameter.
 *
 * @param[in]   user_data       Caller-provided data that will be provided
 *                              in stream callbacks
 *
 *
 * @note  This call should be later followed by a call to
 *        bladerf_deinit_stream() to avoid memory leaks.
 *
 * @return 0 on success,
 *          value from \ref RETCODES list on failure
 */
    pub fn bladerf_init_stream(stream: &*mut bladerf_stream,
                               dev: *mut bladerf, callback: bladerf_stream_cb,
                               buffers: &*mut *mut ::std::os::raw::c_void,
                               num_buffers: usize, format: bladerf_format,
                               samples_per_buffer: usize,
                               num_transfers: usize,
                               user_data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Submit a buffer to a stream from outside of a stream callback function.
 * Use this only when returning BLADERF_STREAM_NO_DATA from callbacks. <b>Do
 * not</b> use this function if the associated callback functions will be
 * returning buffers for submission.
 *
 * This call may block if the device is not ready to submit a buffer for
 * transfer. Use the `timeout_ms` to place an upper limit on the time this
 * function can block.
 *
 * To safely submit buffers from outside the stream callback flow, this function
 * internally acquires a per-stream lock (the same one that is held during the
 * execution of a stream callback). Therefore, it is important to be aware of
 * locks that may be held while making this call, especially those acquired
 * during execution of the associated stream callback function. (i.e., be wary
 * of the order of lock acquisitions, including the internal per-stream lock.)
 *
 * @param   stream      Stream to submit buffer to
 * @param   buffer      Buffer to fill (RX) or containing data (TX). This buffer
 *                      is assumed to be the size specified in the associated
 *                      bladerf_init_stream() call.
 * @param   timeout_ms  Milliseconds to timeout in, if this call blocks. 0
 *                      implies an "infinite" wait.
 *
 * @return  0 on success, BLADERF_ERR_TIMEOUT upon a timeout, or a value from
 * \ref RETCODES list on other failures
 */
    pub fn bladerf_submit_stream_buffer(stream: *mut bladerf_stream,
                                        buffer: *mut ::std::os::raw::c_void,
                                        timeout_ms: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * This is a non-blocking variant of bladerf_submit_stream_buffer(). All of the
 * caveats and important notes from bladerf_submit_stream_buffer() apply.
 *
 * In the event that this call would need to block in order to submit a buffer,
 * it returns BLADERF_ERR_WOULD_BLOCK. In this case, the caller could either
 * wait and try again or defer buffer submission to the asynchronous callback.
 *
 * @param   stream      Stream to submit buffer to
 * @param   buffer      Buffer to fill (RX) or containing data (TX). This buffer
 *                      is assumed to be the size specified in the associated
 *                      bladerf_init_stream() call.
 *
 * @return  0 on success,
 *          BLADERF_ERR_WOULD_BLOCK if the call would have to block to succeed,
 *          or another value from \ref RETCODES upon other failure
 */
    pub fn bladerf_submit_stream_buffer_nb(stream: *mut bladerf_stream,
                                           buffer:
                                               *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Deinitialize and deallocate stream resources.
 *
 * @pre    Stream is no longer being used (via bladerf_submit_stream_buffer() or
 *          bladerf_stream() calls.)
 * @post   Stream is deallocated and may no longer be used.
 *
 * @param   stream      Stream to deinitialize. This function does nothing
 *                      if stream is NULL.
 */
    pub fn bladerf_deinit_stream(stream: *mut bladerf_stream);
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Set stream transfer timeout in milliseconds
 *
 * @param   dev         Device handle
 * @param   module      Module to adjust
 * @param   timeout     Timeout in milliseconds
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_set_stream_timeout(dev: *mut bladerf,
                                      module: bladerf_module,
                                      timeout: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get transfer timeout in milliseconds
 *
 * @param[in]   dev         Device handle
 * @param[in]   module      Module to adjust
 * @param[out]  timeout     On success, updated with current transfer
 *                          timeout value. Undefined on failure.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_get_stream_timeout(dev: *mut bladerf,
                                      module: bladerf_module,
                                      timeout: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * (Re)Configure a device for synchronous transmission or reception
 *
 * This function sets up the device for the specified format and initializes
 * the underlying asynchronous stream parameters
 *
 * This function does not call bladerf_enable_module(). The API user is
 * responsible for enabling/disable modules when desired.
 *
 * Note that (re)configuring ::BLADERF_MODULE_TX does not affect the
 * ::BLADERF_MODULE_RX modules, and vice versa. This call configures each module
 * independently.
 *
 * Memory allocated by this function will be deallocated when bladerf_close()
 * is called.
 *
 * See the bladerf_init_stream() documentation for information on determining
 * appropriate values for `buffers_size`, `num_transfers`, and `stream_timeout`.
 * The `num_buffers` parameter should generally be increased as the amount of
 * work done between bladerf_sync_rx() or bladerf_sync_tx() calls increases.
 *
 * @param   dev             Device to configure
 *
 * @param   module          Module to use with synchronous interface
 *
 * @param   format          Format to use in synchronous data transfers
 *
 * @param   num_buffers     The number of buffers to use in the underlying
 *                          data stream. This must be greater than the
 *                          `num_xfers` parameter.
 *
 * @param   buffer_size     The size of the underlying stream buffers, in
 *                          samples. This value must be a multiple of 1024.
 *                          Note that samples are only transferred when a buffer
 *                          of this size is filled.
 *
 * @param   num_transfers   The number of active USB transfers that may be
 *                          in-flight at any given time. If unsure of what
 *                          to use here, try values of 4, 8, or 16.
 *
 * @param   stream_timeout  Timeout (milliseconds) for transfers in the
 *                          underlying data stream.
 *
 * @return 0 on success,
 *         BLADERF_ERR_UNSUPPORTED if libbladeRF is not built with support
 *         for this functionality,
 *         or a value from \ref RETCODES list on failures.
 */
    pub fn bladerf_sync_config(dev: *mut bladerf, module: bladerf_module,
                               format: bladerf_format,
                               num_buffers: ::std::os::raw::c_uint,
                               buffer_size: ::std::os::raw::c_uint,
                               num_transfers: ::std::os::raw::c_uint,
                               stream_timeout: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Transmit IQ samples.
 *
 * Under the hood, this call starts up an underlying asynchronous stream as
 * needed. This stream can be stopped by disabling the TX module. (See
 * bladerf_enable_module for more details.)
 *
 * Samples will only be sent to the FPGA when a buffer have been filled. The
 * number of samples required to fill a buffer corresponds to the `buffer_size`
 * parameter passed to bladerf_sync_config().
 *
 * @param[in]   dev         Device handle
 *
 * @param[in]   samples     Array of samples
 *
 * @param[in]   num_samples Number of samples to write
 *
 * @param[in]   metadata    Sample metadata. This must be provided when using
 *                          the ::BLADERF_FORMAT_SC16_Q11_META format, but may
 *                          be NULL when the interface is configured for
 *                          the ::BLADERF_FORMAT_SC16_Q11 format.
 *
 * @param[in]   timeout_ms  Timeout (milliseconds) for this call to complete.
 *                          Zero implies "infinite."
 *
 * @pre A bladerf_sync_config() call has been to configure the device for
 *      synchronous data transfer.
 *
 * @pre A call to bladerf_enable_module() should be made before attempting to
 *      transmit samples. Failing to do this may result in timeouts and other
 *      errors.
 *
 * @return 0 on success,
 *         BLADERF_ERR_UNSUPPORTED if libbladeRF is not built with support
 *         for this functionality,
 *         or a value from \ref RETCODES list on failures.
 */
    pub fn bladerf_sync_tx(dev: *mut bladerf,
                           samples: *mut ::std::os::raw::c_void,
                           num_samples: ::std::os::raw::c_uint,
                           metadata: *mut bladerf_metadata,
                           timeout_ms: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Receive IQ samples.
 *
 * Under the hood, this call starts up an underlying asynchronous stream as
 * needed. This stream can be stopped by disabling the RX module. (See
 * bladerf_enable_module for more details.)
 *
 * @param[in]   dev         Device handle
 *
 * @param[out]  samples     Buffer to store samples in. The caller is
 *                          responsible for ensuring this buffer is sufficiently
 *                          large for the number of samples requested,
 *                          considering the size of the sample format being
 *                          used.
 *
 * @param[in]   num_samples Number of samples to read
 *
 * @param[out]  metadata    Sample metadata. This must be provided when using
 *                          the ::BLADERF_FORMAT_SC16_Q11_META format, but may
 *                          be NULL when the interface is configured for
 *                          the ::BLADERF_FORMAT_SC16_Q11 format.
 *
 * @param[in]   timeout_ms  Timeout (milliseconds) for this call to complete.
 *                          Zero implies "infinite."
 *
 * @pre A bladerf_sync_config() call has been to configure the device for
 *      synchronous data transfer.
 *
 * @pre A call to bladerf_enable_module() should be made before attempting to
 *      receive samples. Failing to do this may result in timeouts and other
 *      errors.
 *
 *
 * @return 0 on success,
 *         BLADERF_ERR_UNSUPPORTED if libbladeRF is not built with support
 *         for this functionality,
 *         or a value from \ref RETCODES list on failures.
 */
    pub fn bladerf_sync_rx(dev: *mut bladerf,
                           samples: *mut ::std::os::raw::c_void,
                           num_samples: ::std::os::raw::c_uint,
                           metadata: *mut bladerf_metadata,
                           timeout_ms: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write FX3 firmware to the bladeRF's SPI flash
 *
 * @note This will require a power cycle to take effect
 *
 * @param   dev         Device handle
 * @param   firmware    Full path to firmware file
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_flash_firmware(dev: *mut bladerf,
                                  firmware: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Load device's FPGA. Note that this FPGA configuration will be reset
 * at the next power cycle.
 *
 * @param   dev         Device handle
 * @param   fpga        Full path to FPGA bitstream
 *
 * @return 0 upon successfully, or a value from \ref RETCODES list on failure
 */
    pub fn bladerf_load_fpga(dev: *mut bladerf,
                             fpga: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write the provided FPGA image to the bladeRF's SPI flash and enable FPGA
 * loading from SPI flash at power on (also referred to within this project as
 * FPGA "autoloading").
 *
 * @param   dev         Device handle
 * @param   fpga_image  Full path to FPGA file
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_flash_fpga(dev: *mut bladerf,
                              fpga_image: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Erase the FPGA region of SPI flash, effectively disabling FPGA autoloading
 *
 * @param   dev         Device handle
 */
    pub fn bladerf_erase_stored_fpga(dev: *mut bladerf)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Reset the device, causing it to reload its firmware from flash
 *
 * @param   dev         Device handle
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_device_reset(dev: *mut bladerf) -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Clear out a firmware signature word in flash and jump to FX3 bootloader.
 *
 * The device will continue to boot into the FX3 bootloader across power cycles
 * until new firmware is written to the device.
 *
 * @param   dev         Device handle
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_jump_to_bootloader(dev: *mut bladerf)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Get a list of devices that are running the FX3 bootloader.
 *
 * After obtaining this list, identify the device that you would like to load
 * firmware onto. Save the bus and address values so that you can provide them
 * to bladerf_load_fw_from_bootloader(), and then free this list via
 * bladerf_free_device_list().
 *
 * @param[out]   list    Upon finding devices, this will be updated to point
 *                       to a list of bladerf_devinfo structures that
 *                       describe the identified devices.
 *
 * @return Number of items populated in `list`,
 *         or an error value from the \ref RETCODES list on failure
 */
    pub fn bladerf_get_bootloader_list(list: &*mut bladerf_devinfo)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Download firmware to the specified device that is enumarating an FX3
 * bootloader, and begin executing the firmware from RAM.
 *
 * Note that this function <b>does not</b> write the firmware to SPI flash.
 * If this is desired, open the newly enumerated device with bladerf_open() and
 * use bladerf_flash_firmware().
 *
 * @param device_identifier   Device identifier string describing the
 *                            backend to use via the
 *                              `<backend>:device=<bus>:<addr>` syntax.
 *                            If this is NULL, the backend, bus, and addr
 *                            arguments will be used instead.
 *
 * @param backend             Backend to use. This is only used if
 *                              device_identifier is NULL.
 *
 * @param bus                 Bus number the device is located on. This is only
 *                              used if device_identifier is NULL.
 *
 * @param addr                Bus address the device is located on. This is only
 *                              used if device_identifier is NULL.
 *
 * @param file                Filename of the firmware image to boot
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 *
 *
 */
    pub fn bladerf_load_fw_from_bootloader(device_identifier:
                                               *const ::std::os::raw::c_char,
                                           backend: bladerf_backend, bus: u8,
                                           addr: u8,
                                           file:
                                               *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub const BLADERF_IMAGE_TYPE_INVALID: _bindgen_ty_29 =
    _bindgen_ty_29::BLADERF_IMAGE_TYPE_INVALID;
pub const BLADERF_IMAGE_TYPE_RAW: _bindgen_ty_29 =
    _bindgen_ty_29::BLADERF_IMAGE_TYPE_RAW;
pub const BLADERF_IMAGE_TYPE_FIRMWARE: _bindgen_ty_29 =
    _bindgen_ty_29::BLADERF_IMAGE_TYPE_FIRMWARE;
pub const BLADERF_IMAGE_TYPE_FPGA_40KLE: _bindgen_ty_29 =
    _bindgen_ty_29::BLADERF_IMAGE_TYPE_FPGA_40KLE;
pub const BLADERF_IMAGE_TYPE_FPGA_115KLE: _bindgen_ty_29 =
    _bindgen_ty_29::BLADERF_IMAGE_TYPE_FPGA_115KLE;
pub const BLADERF_IMAGE_TYPE_CALIBRATION: _bindgen_ty_29 =
    _bindgen_ty_29::BLADERF_IMAGE_TYPE_CALIBRATION;
pub const BLADERF_IMAGE_TYPE_RX_DC_CAL: _bindgen_ty_29 =
    _bindgen_ty_29::BLADERF_IMAGE_TYPE_RX_DC_CAL;
pub const BLADERF_IMAGE_TYPE_TX_DC_CAL: _bindgen_ty_29 =
    _bindgen_ty_29::BLADERF_IMAGE_TYPE_TX_DC_CAL;
pub const BLADERF_IMAGE_TYPE_RX_IQ_CAL: _bindgen_ty_29 =
    _bindgen_ty_29::BLADERF_IMAGE_TYPE_RX_IQ_CAL;
pub const BLADERF_IMAGE_TYPE_TX_IQ_CAL: _bindgen_ty_29 =
    _bindgen_ty_29::BLADERF_IMAGE_TYPE_TX_IQ_CAL;
#[repr(i32)]
/** Type of data stored in a flash image */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_29 {
    BLADERF_IMAGE_TYPE_INVALID = -1,
    BLADERF_IMAGE_TYPE_RAW = 0,
    BLADERF_IMAGE_TYPE_FIRMWARE = 1,
    BLADERF_IMAGE_TYPE_FPGA_40KLE = 2,
    BLADERF_IMAGE_TYPE_FPGA_115KLE = 3,
    BLADERF_IMAGE_TYPE_CALIBRATION = 4,
    BLADERF_IMAGE_TYPE_RX_DC_CAL = 5,
    BLADERF_IMAGE_TYPE_TX_DC_CAL = 6,
    BLADERF_IMAGE_TYPE_RX_IQ_CAL = 7,
    BLADERF_IMAGE_TYPE_TX_IQ_CAL = 8,
}
pub use self::_bindgen_ty_29 as bladerf_image_type;
/**
 * Image format for backing up and restoring bladeRF flash contents
 *
 * The on disk format generated by the bladerf_image_write function is a
 * serialized version of this structure and its contents. When written to disk,
 * values are converted to big-endian byte order, for ease of reading in a hex
 * editor.
 *
 * When creating and using a bladerf_image of type BLADERF_IMAGE_TYPE_RAW,
 * the address and length fields must be erase-block aligned.
 */
#[repr(C)]
pub struct bladerf_image {
    /**
     * Magic value used to identify image file format.
     *
     * Note that an extra character is added to store a NUL-terminator,
     * to allow this field to be printed. This NUL-terminator is *NOT*
     * written in the serialized image.
     */
    pub magic: [::std::os::raw::c_char; 8usize],
    /**
     * SHA256 checksum of the flash image. This is computed over the entire
     * image, with this field filled with 0's.
     */
    pub checksum: [u8; 32usize],
    /**
     * Image format version. Only the major, minor, and patch fields are
     * written to the disk; the describe field is not used. The version is
     * serialized as: [major | minor | patch]
     */
    pub version: bladerf_version,
    /** UTC image timestamp, in seconds since the Unix Epoch */
    pub timestamp: u64,
    /**
     * Serial number of the device that the image was obtained from. This
     * field should be all '\0' if irrelevant.
     *
     * The +1 here is actually extraneous; BLADERF_SERIAL_LENGTH already
     * accounts for a NUL terminator. However, this is left here to avoid
     * breaking backwards compatibility.
     */
    pub serial: [::std::os::raw::c_char; 34usize],
    /**
     * Reserved for future metadata. Should be 0's.
     */
    pub reserved: [::std::os::raw::c_char; 128usize],
    /**
     * Type of data contained in the image. Serialized as a uint32_t.
     */
    pub type_: bladerf_image_type,
    /**
     * Address of the flash data in this image. A value of 0xffffffff
     * implies that this field is left unspecified (i.e., "don't care").
     */
    pub address: u32,
    /** Length of the data contained in the image */
    pub length: u32,
    /** Image data */
    pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_bladerf_image() {
    assert_eq!(::std::mem::size_of::<bladerf_image>() , 248usize);
    assert_eq!(::std::mem::align_of::<bladerf_image>() , 8usize);
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Allocate and initialize an image structure.
 *
 * This following bladerf_image fields are populated: `magic`, `version`,
 * `timestamp`, `type`, `address`, and `length`
 *
 * The following bladerf_image fields are zeroed out:  `checksum`, `serial`, and
 * `reserved`,
 *
 * If the `length` parameter is not 0, the bladerf_image `data` field will be
 * dynamically allocated. Otherwise, `data` will be set to NULL.
 *
 * @note A non-zero `lenth` should be use only with bladerf_image_write();
 * bladerf_image_read() allocates and sets `data` based upon size of the image
 * contents, and does not attempt to free() the `data` field before setting it.
 *
 * The `address` and `length` fields should be set 0 when reading an image from
 * a file.
 *
 * @return Pointer to allocated and initialized structure on success,
 *         NULL on memory allocation failure or invalid address/length.
 */
    pub fn bladerf_alloc_image(type_: bladerf_image_type, address: u32,
                               length: u32) -> *mut bladerf_image;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Create a flash image initialized to contain a calibration data region.
 * This is intended to be used in conjunction with bladerf_image_write(),
 * or a write of the image's `data` field to flash.
 *
 * @param   fpga_size    Target FPGA size
 * @param   vctcxo_trim  VCTCXO oscillator trim value.
 *
 * @return Pointer to allocated and initialized structure on success,
 *         NULL on memory allocation failure
 */
    pub fn bladerf_alloc_cal_image(fpga_size: bladerf_fpga_size,
                                   vctcxo_trim: u16) -> *mut bladerf_image;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Free a bladerf_image previously obtained via bladerf_alloc_image.
 * If the bladerf_image's `data` field is non-NULL, it will be freed.
 */
    pub fn bladerf_free_image(image: *mut bladerf_image);
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write a flash image to a file.
 *
 * This function will fill in the checksum field before writing the contents to
 * the specified file. The user-supplied contents of this field are ignored.
 *
 * @pre   `image` has been initialized using bladerf_alloc_image()
 * @post `image->checksum` will be populated if this function succeeds
 *
 * @param[in]    image       Flash image
 * @param[in]    file        File to write the flash image to
 *
 * @return 0 upon success, or a value from \ref RETCODES list on failure
 */
    pub fn bladerf_image_write(image: *mut bladerf_image,
                               file: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read flash image from a file.
 *
 * @param[out]   image      Flash image structure to populate.
 *
 * @param[in]    file       File to read image from.
 *
 * @pre  The `image` parameter has been obtained via a call to
 *       bladerf_alloc_image(), with a `length` of 0.
 *
 * @post The `image` fields will be populated upon success, overwriting
 *       any previous values.
 *
 * @note The contents of the `image` paramater should not be used if this
 *       function fails.
 *
 *
 * @return 0 upon success,<br>
 *         BLADERF_ERR_CHECKSUM upon detecting a checksum mismatch,<br>
 *         BLADERF_ERR_INVAL if any image fields are invalid,<br>
 *         BLADERF_ERR_IO on a file I/O error,<br>
 *         or a value from \ref RETCODES list on any other failure<br>
 */
    pub fn bladerf_image_read(image: *mut bladerf_image,
                              file: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read a Si5338 register
 *
 * @param   dev         Device handle
 * @param   address     Si5338 register offset
 * @param   val         Pointer to variable the data should be read into
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_si5338_read(dev: *mut bladerf, address: u8, val: *mut u8)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write a Si5338 register
 *
 * @param   dev         Device handle
 * @param   address     Si5338 register offset
 * @param   val         Data to write to register
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_si5338_write(dev: *mut bladerf, address: u8, val: u8)
     -> ::std::os::raw::c_int;
}
/**
 * This structure is used to directly apply DC calibration register values to
 * the LMS, rather than use the values resulting from an auto-calibration.
 *
 * A value < 0 is used to denote that the specified value should not
 * be written.  If a value is to be written, it will be truncated to 8-bits.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bladerf_lms_dc_cals {
    /**< LPF tuning module */
    pub lpf_tuning: i16,
    /**< TX LPF I filter */
    pub tx_lpf_i: i16,
    /**< TX LPF Q filter */
    pub tx_lpf_q: i16,
    /**< RX LPF I filter */
    pub rx_lpf_i: i16,
    /**< RX LPF Q filter */
    pub rx_lpf_q: i16,
    /**< RX VGA2 DC reference module */
    pub dc_ref: i16,
    /**< RX VGA2, I channel of first gain stage */
    pub rxvga2a_i: i16,
    /**< RX VGA2, Q channel of first gain stage */
    pub rxvga2a_q: i16,
    /**< RX VGA2, I channel of second gain stage */
    pub rxvga2b_i: i16,
    /**< RX VGA2, Q channel of second gain stage */
    pub rxvga2b_q: i16,
}
#[test]
fn bindgen_test_layout_bladerf_lms_dc_cals() {
    assert_eq!(::std::mem::size_of::<bladerf_lms_dc_cals>() , 20usize);
    assert_eq!(::std::mem::align_of::<bladerf_lms_dc_cals>() , 2usize);
}
impl Clone for bladerf_lms_dc_cals {
    fn clone(&self) -> Self { *self }
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read a LMS register
 *
 * @param   dev         Device handle
 * @param   address     LMS register offset
 * @param   val         Pointer to variable the data should be read into
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_lms_read(dev: *mut bladerf, address: u8, val: *mut u8)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write a LMS register
 *
 * @param   dev         Device handle
 * @param   address     LMS register offset
 * @param   val         Data to write to register
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_lms_write(dev: *mut bladerf, address: u8, val: u8)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Manually load values into LMS6002 DC calibration registers.
 *
 * This is generally intended for applying a set of known values resulting from
 * a previous run of the LMS autocalibrations.
 *
 * @param   dev        Device handle
 * @param   dc_cals    Calibration values to load. Values set to <0 will
 *                     not be applied.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_lms_set_dc_cals(dev: *mut bladerf,
                                   dc_cals: *const bladerf_lms_dc_cals)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Retrieve the current DC calibration values from the LMS6002
 *
 * @param[in]   dev        Device handle
 * @param[out]  dc_cals    Populated with current values
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_lms_get_dc_cals(dev: *mut bladerf,
                                   dc_cals: *mut bladerf_lms_dc_cals)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read a configuration GPIO register
 *
 * @param   dev         Device handle
 * @param   val         Pointer to variable the data should be read into
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_config_gpio_read(dev: *mut bladerf, val: *mut u32)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write a configuration GPIO register. Callers should be sure to perform a
 * read-modify-write sequence to avoid accidentally clearing other
 * GPIO bits that may be set by the library internally.
 *
 * @param   dev         Device handle
 * @param   val         Data to write to GPIO register
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_config_gpio_write(dev: *mut bladerf, val: u32)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write value to secondary XB SPI
 *
 * @param   dev         Device handle
 * @param   val         Data to write to XB SPI
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_xb_spi_write(dev: *mut bladerf, val: u32)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Perform DC calibration
 *
 * @param   dev         Device handle
 * @param   module      Module to calibrate
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_calibrate_dc(dev: *mut bladerf, module: bladerf_cal_module)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read trigger control register
 *
 * @param   dev             Device handle
 * @param   module          Module to read from
 * @param   signal          Trigger signal (control register) to read from
 * @param   val             Pointer to variable that register is read into
 *                          See the BLADERF_TRIGGER_REG_* macros for the meaning
 *                          of each bit.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_read_trigger(dev: *mut bladerf, module: bladerf_module,
                                signal: bladerf_trigger_signal, val: *mut u8)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write trigger control register
 *
 * @param   dev             Device handle
 * @param   module          Module to configure
 * @param   signal          Trigger signal to configure
 * @param   val             Data to write into the trigger control register.
 *                          See the BLADERF_TRIGGER_REG_* macros for options.
 *
 * @return 0 on success, value from \ref RETCODES list on failure
 */
    pub fn bladerf_write_trigger(dev: *mut bladerf, module: bladerf_module,
                                 signal: bladerf_trigger_signal, val: u8)
     -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Erase regions of the bladeRF's SPI flash
 *
 * This function operates in units of 64KiB erase blocks
 *
 * @param   dev             Device handle
 * @param   erase_block     Erase block to start erasing at
 * @param   count           Number of blocks to erase.
 *
 * @return 0 on success, or BLADERF_ERR_INVAL on an invalid `erase_block` or
 *         `count` value, or a value from \ref RETCODES list on other failures
 */
    pub fn bladerf_erase_flash(dev: *mut bladerf, erase_block: u32,
                               count: u32) -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Read data from the bladeRF's SPI flash
 *
 * This function operates in units of 256-byte pages.
 *
 * @param   dev     Device handle
 * @param   buf     Buffer to read data into. Must be
 *                  `count` * BLADERF_FLASH_PAGE_SIZE bytes or larger.
 *
 * @param   page    Page to begin reading from
 * @param   count   Number of pages to read
 *
 * @return 0 on success, or BLADERF_ERR_INVAL on an invalid `page` or
 *         `count` value, or a value from \ref RETCODES list on other failures.
 */
    pub fn bladerf_read_flash(dev: *mut bladerf, buf: *mut u8, page: u32,
                              count: u32) -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Write data to the bladeRF's SPI flash device
 *
 * @param   dev   Device handle
 * @param   buf   Data to write to flash
 *
 * @param   page  Page to begin writing at
 * @param   count Number of pages to write
 *
 * @return 0 on success, or BLADERF_ERR_INVAL on an invalid `page` or
 *         `count` value, or a value from \ref RETCODES list on other failures.
 */
    pub fn bladerf_write_flash(dev: *mut bladerf, buf: *const u8, page: u32,
                               count: u32) -> ::std::os::raw::c_int;
}
#[link(name = "bladeRF")] extern "C" {
    /**
 * Obtain a textual description of a value from the \ref RETCODES list
 *
 * @warning Do not attempt to modify the returned string.
 *
 * @param   error   Error value to look up
 * @return  Error string
 */
    pub fn bladerf_strerror(error: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
